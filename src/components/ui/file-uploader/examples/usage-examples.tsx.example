// examples/usage-examples.tsx
// Example usage patterns for the unified FileUploader component

import React, { useState } from 'react';
import { FileUploader, ImageDisplay } from '../index';
import type { FileWithId } from '../types/file-uploader.types';

/**
 * Example 1: Profile Image Upload (External Upload Management)
 * Demonstrates temporary upload with signed URL preview
 */
export const ProfileImageUploadExample = () => {
    const [selectedFiles, setSelectedFiles] = useState<FileWithId[]>([]);
    const [previewUrls, setPreviewUrls] = useState<Record<string, string>>({});
    const [isUploading, setIsUploading] = useState(false);
    
    // These would be your actual orval hooks
    // const profileHooks = useProfileHooks();
    // const { mutate: uploadProfileImage } = profileHooks.uploadProfileImage();
    // const { mutateAsync: getSignedUrls } = profileHooks.getImageSignedUrls();
    
    const handleFileSelect = async (filesWithId: FileWithId[]) => {
        setSelectedFiles(filesWithId);
        setIsUploading(true);
        
        try {
            // You decide: temporary upload, permanent upload, or just preview
            const fileWithId = filesWithId[0];
            const file = fileWithId.file;
            
            // Option 1: Upload to temporary storage first for preview
            // const tempResult = await uploadToTempStorage(file);
            
            // Get signed URL for preview (signed URL has priority over blob)
            // const signedUrlResponse = await getSignedUrls({
            //     data: { image_storage_paths: [tempResult.temp_id] }
            // });
            
            // Use unique fileId as key (no name collisions)
            // setPreviewUrls({
            //     [fileWithId.fileId]: signedUrlResponse.urls[0].url
            // });
            
            console.log('File selected:', file.name);
            
        } catch (error) {
            console.error('Upload failed:', error);
        } finally {
            setIsUploading(false);
        }
    };
    
    const handleFileRemove = (fileId: string) => {
        setSelectedFiles(prev => prev.filter(f => f.fileId !== fileId));
        setPreviewUrls(prev => {
            const newUrls = { ...prev };
            delete newUrls[fileId];
            return newUrls;
        });
    };
    
    return (
        <FileUploader
            fileType="image"
            onFileSelect={handleFileSelect}
            onFileRemove={handleFileRemove}
            selectedFiles={selectedFiles}
            previewUrls={previewUrls} // Component automatically handles signed URL priority
            isUploading={isUploading}
            preview={{ 
                enabled: true, 
                type: 'full'
            }}
            className="w-full h-64"
        />
    );
};

/**
 * Example 2: Verification Document Upload (Form-Based with Staging)
 * Demonstrates multiple document types with validation
 */
export const VerificationDocumentUploadExample = () => {
    const [selectedFiles, setSelectedFiles] = useState<FileWithId[]>([]);
    const [previewUrls, setPreviewUrls] = useState<Record<string, string>>({});
    const [isProcessing, setIsProcessing] = useState(false);
    
    const handleFileSelect = async (filesWithId: FileWithId[]) => {
        setSelectedFiles(filesWithId);
        setIsProcessing(true);
        
        // Simulate processing
        setTimeout(() => {
            setIsProcessing(false);
        }, 2000);
    };
    
    const handleFileRemove = (fileId: string) => {
        setSelectedFiles(prev => prev.filter(f => f.fileId !== fileId));
    };
    
    return (
        <FileUploader
            fileType="document"
            accept={{
                mimeTypes: ['application/pdf', 'image/*'],
                extensions: ['.pdf', '.png', '.jpg'],
                description: 'Verification documents'
            }}
            maxSize={10 * 1024 * 1024}
            multiple={true}
            onFileSelect={handleFileSelect}
            onFileRemove={handleFileRemove}
            selectedFiles={selectedFiles}
            previewUrls={previewUrls}
            isProcessing={isProcessing}
            preview={{ 
                enabled: true, 
                type: 'thumbnail'
            }}
        />
    );
};

/**
 * Example 3: Simple Preview-Only Mode (No Upload)
 * Just file selection with blob URL preview
 */
export const ImagePreviewSelectorExample = () => {
    const [selectedFiles, setSelectedFiles] = useState<FileWithId[]>([]);
    
    const handleFileSelect = (filesWithId: FileWithId[]) => {
        setSelectedFiles(filesWithId);
        // Just store files, no upload - consumer decides what to do
        console.log('Files selected:', filesWithId.map(f => f.name));
    };
    
    const handleFileRemove = (fileId: string) => {
        setSelectedFiles(prev => prev.filter(f => f.fileId !== fileId));
    };
    
    return (
        <FileUploader
            fileType="image"
            multiple={true}
            onFileSelect={handleFileSelect}
            onFileRemove={handleFileRemove}
            selectedFiles={selectedFiles}
            preview={{ 
                enabled: true, 
                type: 'gallery'
                // No previewUrls provided - component uses blob URLs automatically
            }}
            variant="dropzone"
        />
    );
};

/**
 * Example 4: Standalone Image Display with S3 Integration
 * For displaying existing images with signed URLs
 */
export const ImageDisplayExample = () => {
    // Mock data - in real usage these would come from your API
    const userId = 'user-123';
    const profileImageId = 'profile-image-456';
    
    return (
        <div className="space-y-4">
            <h3>Profile Image</h3>
            <ImageDisplay
                imageId={profileImageId}
                onGetSignedUrls={async (imageIds) => {
                    // Mock signed URL response - replace with actual orval hook
                    return {
                        ttl_seconds: 3600,
                        expires_at: new Date(Date.now() + 3600000).toISOString(),
                        urls: imageIds.map(id => ({
                            media_id: id,
                            url: `https://example.com/signed-url/${id}?expires=...`
                        }))
                    };
                }}
                alt="Profile image"
                className="w-24 h-24 rounded-full object-cover border border-[#575757]"
                fallback={
                    <div className="w-24 h-24 rounded-full bg-[#202020] border border-[#575757] flex items-center justify-center">
                        <span className="text-[#D78E59] font-bold text-2xl">
                            {userId.charAt(0).toUpperCase()}
                        </span>
                    </div>
                }
                cacheKey={`profile-${userId}`}
            />
        </div>
    );
};

/**
 * Example 5: Category Management with Pending Changes
 * Demonstrates sophisticated state management similar to existing category modal
 */
export const CategoryImageManagementExample = () => {
    const [selectedFiles, setSelectedFiles] = useState<FileWithId[]>([]);
    const [previewUrls, setPreviewUrls] = useState<Record<string, string>>({});
    const [pendingImageFile, setPendingImageFile] = useState<File | null>(null);
    const [hasPendingChanges, setHasPendingChanges] = useState(false);
    
    const handleFileSelect = async (filesWithId: FileWithId[]) => {
        const fileWithId = filesWithId[0]; // Single image for category
        setSelectedFiles([fileWithId]);
        setPendingImageFile(fileWithId.file);
        setHasPendingChanges(true);
        
        // Create blob URL for immediate preview
        const blobUrl = URL.createObjectURL(fileWithId.file);
        setPreviewUrls({ [fileWithId.fileId]: blobUrl });
        
        // Optionally upload to temporary storage and get signed URL
        // Similar to existing category implementation
    };
    
    const handleFileRemove = (fileId: string) => {
        setSelectedFiles([]);
        setPendingImageFile(null);
        setHasPendingChanges(false);
        setPreviewUrls({});
    };
    
    const handleSaveChanges = async () => {
        if (pendingImageFile) {
            // Upload and save - similar to existing category save logic
            console.log('Saving image:', pendingImageFile.name);
            setHasPendingChanges(false);
        }
    };
    
    return (
        <div className="space-y-4">
            <FileUploader
                fileType="image"
                onFileSelect={handleFileSelect}
                onFileRemove={handleFileRemove}
                selectedFiles={selectedFiles}
                previewUrls={previewUrls}
                preview={{ 
                    enabled: true, 
                    type: 'full'
                }}
                variant="dropzone"
                className="border border-[#575757] rounded-lg"
            />
            
            {hasPendingChanges && (
                <div className="flex gap-2">
                    <button 
                        onClick={handleSaveChanges}
                        className="px-4 py-2 bg-[#D78E59] text-[#171717] rounded hover:bg-[#FFAA6C]"
                    >
                        Save Changes
                    </button>
                    <button 
                        onClick={() => handleFileRemove(selectedFiles[0]?.fileId || '')}
                        className="px-4 py-2 border border-[#575757] text-[#828288] rounded hover:text-[#EDECF8]"
                    >
                        Cancel
                    </button>
                </div>
            )}
        </div>
    );
};