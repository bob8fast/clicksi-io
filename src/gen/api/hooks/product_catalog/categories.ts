/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * ProductCatalog.API
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  BulkUpdateCategoriesBody,
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  DeleteCategoryImagePathParameters,
  GetCategoriesParams,
  GetCategoryHistoryDetailsPathParameters,
  ProductCatalogDomainDTOsCategoryDto,
  ProductCatalogDomainDTOsCategoryImageUpdateResponse,
  ProductCatalogDomainDTOsCategoryImageUrlsResponse,
  ProductCatalogDomainDTOsCategoryOperationResponse,
  ProductCatalogDomainDTOsCategorySearchRequest,
  ProductCatalogDomainDTOsCategoryTreeHistoryDetailDto,
  ProductCatalogDomainDTOsCategoryTreeHistoryDto,
  ProductCatalogDomainDTOsGetCategoryHistoryRequest,
  ProductCatalogDomainDTOsGetCategoryImageUrlsRequest,
  ProductCatalogDomainDTOsRecoverToHistoricalStateRequest,
  ProductCatalogDomainDTOsRecoveryResult,
  UploadCategoryImageBody,
} from "../../types";

import { gatewayServiceCustomFetch } from "../../../../lib/orval/orval-fetch";
import { customQueryOptions } from "../../../../lib/orval/custom-query-options";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Get categories by type
 */
export const getGetCategoriesUrl = (params?: GetCategoriesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/product-catalog/api/v1/categories?${stringifiedParams}`
    : `/product-catalog/api/v1/categories`;
};

export const getCategories = async (
  params?: GetCategoriesParams,
  options?: RequestInit,
): Promise<ProductCatalogDomainDTOsCategoryDto[]> => {
  return gatewayServiceCustomFetch<ProductCatalogDomainDTOsCategoryDto[]>(
    getGetCategoriesUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetCategoriesQueryKey = (params?: GetCategoriesParams) => {
  return [
    "product-catalog",
    "api",
    "v1",
    "categories",
    ...(params ? [params] : []),
  ] as const;
};

export const useGetCategoriesInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetCategoriesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategories>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({
    signal,
  }) => getCategories(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategories>>
>;
export type GetCategoriesInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetCategoriesParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategories>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetCategoriesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategories>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetCategoriesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategories>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get categories by type
 */

export function useGetCategoriesInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetCategoriesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategories>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetCategoriesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get categories by type
 */
export const prefetchGetCategoriesInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetCategoriesParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategories>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetCategoriesInfiniteQueryOptions(params, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetCategoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({
    signal,
  }) => getCategories(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getCategories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategories>>
>;
export type GetCategoriesQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetCategories<
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetCategoriesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategories<
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetCategoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategories>>,
          TError,
          Awaited<ReturnType<typeof getCategories>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategories<
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetCategoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get categories by type
 */

export function useGetCategories<
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetCategoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetCategoriesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get categories by type
 */
export const prefetchGetCategoriesQuery = async <
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetCategoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetCategoriesQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Delete category image
 */
export const getDeleteCategoryImageUrl = ({
  categoryId,
}: DeleteCategoryImagePathParameters) => {
  return `/product-catalog/api/v1/categories/${categoryId}/image`;
};

export const deleteCategoryImage = async (
  { categoryId }: DeleteCategoryImagePathParameters,
  options?: RequestInit,
): Promise<ProductCatalogDomainDTOsCategoryImageUpdateResponse> => {
  return gatewayServiceCustomFetch<ProductCatalogDomainDTOsCategoryImageUpdateResponse>(
    getDeleteCategoryImageUrl({ categoryId }),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getDeleteCategoryImageMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCategoryImage>>,
    TError,
    { pathParams: DeleteCategoryImagePathParameters },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCategoryImage>>,
  TError,
  { pathParams: DeleteCategoryImagePathParameters },
  TContext
> => {
  const mutationKey = ["deleteCategoryImage"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCategoryImage>>,
    { pathParams: DeleteCategoryImagePathParameters }
  > = (props) => {
    const { pathParams } = props ?? {};

    return deleteCategoryImage(pathParams, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteCategoryImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCategoryImage>>
>;

export type DeleteCategoryImageMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Delete category image
 */
export const useDeleteCategoryImage = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteCategoryImage>>,
      TError,
      { pathParams: DeleteCategoryImagePathParameters },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteCategoryImage>>,
  TError,
  { pathParams: DeleteCategoryImagePathParameters },
  TContext
> => {
  const mutationOptions = getDeleteCategoryImageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Bulk update categories with media files
 */
export const getBulkUpdateCategoriesUrl = () => {
  return `/product-catalog/api/v1/categories/bulk-update`;
};

export const bulkUpdateCategories = async (
  bulkUpdateCategoriesBody: BulkUpdateCategoriesBody,
  options?: RequestInit,
): Promise<ProductCatalogDomainDTOsCategoryOperationResponse> => {
  const formData = new FormData();
  formData.append(`CategoryType`, bulkUpdateCategoriesBody.CategoryType);
  bulkUpdateCategoriesBody.Categories.forEach((value) =>
    formData.append(`Categories`, JSON.stringify(value)),
  );
  if (bulkUpdateCategoriesBody.ChangeDescription !== undefined) {
    formData.append(
      `ChangeDescription`,
      bulkUpdateCategoriesBody.ChangeDescription,
    );
  }

  return gatewayServiceCustomFetch<ProductCatalogDomainDTOsCategoryOperationResponse>(
    getBulkUpdateCategoriesUrl(),
    {
      ...options,
      method: "POST",
      body: formData,
    },
  );
};

export const getBulkUpdateCategoriesMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkUpdateCategories>>,
    TError,
    { data: BulkUpdateCategoriesBody },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkUpdateCategories>>,
  TError,
  { data: BulkUpdateCategoriesBody },
  TContext
> => {
  const mutationKey = ["bulkUpdateCategories"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkUpdateCategories>>,
    { data: BulkUpdateCategoriesBody }
  > = (props) => {
    const { data } = props ?? {};

    return bulkUpdateCategories(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type BulkUpdateCategoriesMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkUpdateCategories>>
>;
export type BulkUpdateCategoriesMutationBody = BulkUpdateCategoriesBody;
export type BulkUpdateCategoriesMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Bulk update categories with media files
 */
export const useBulkUpdateCategories = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkUpdateCategories>>,
      TError,
      { data: BulkUpdateCategoriesBody },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkUpdateCategories>>,
  TError,
  { data: BulkUpdateCategoriesBody },
  TContext
> => {
  const mutationOptions = getBulkUpdateCategoriesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get category tree history
 */
export const getGetCategoryHistoryUrl = () => {
  return `/product-catalog/api/v1/categories/history`;
};

export const getCategoryHistory = async (
  productCatalogDomainDTOsGetCategoryHistoryRequest: ProductCatalogDomainDTOsGetCategoryHistoryRequest,
  options?: RequestInit,
): Promise<ProductCatalogDomainDTOsCategoryTreeHistoryDto[]> => {
  return gatewayServiceCustomFetch<
    ProductCatalogDomainDTOsCategoryTreeHistoryDto[]
  >(getGetCategoryHistoryUrl(), {
    ...options,
    method: "POST",
    headers: {
      "Content-Type": "application/json-patch+json",
      ...options?.headers,
    },
    body: JSON.stringify(productCatalogDomainDTOsGetCategoryHistoryRequest),
  });
};

export const getGetCategoryHistoryMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getCategoryHistory>>,
    TError,
    { data: ProductCatalogDomainDTOsGetCategoryHistoryRequest },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getCategoryHistory>>,
  TError,
  { data: ProductCatalogDomainDTOsGetCategoryHistoryRequest },
  TContext
> => {
  const mutationKey = ["getCategoryHistory"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCategoryHistory>>,
    { data: ProductCatalogDomainDTOsGetCategoryHistoryRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getCategoryHistory(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetCategoryHistoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryHistory>>
>;
export type GetCategoryHistoryMutationBody =
  ProductCatalogDomainDTOsGetCategoryHistoryRequest;
export type GetCategoryHistoryMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Get category tree history
 */
export const useGetCategoryHistory = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getCategoryHistory>>,
      TError,
      { data: ProductCatalogDomainDTOsGetCategoryHistoryRequest },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof getCategoryHistory>>,
  TError,
  { data: ProductCatalogDomainDTOsGetCategoryHistoryRequest },
  TContext
> => {
  const mutationOptions = getGetCategoryHistoryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get category history details
 */
export const getGetCategoryHistoryDetailsUrl = ({
  historyId,
}: GetCategoryHistoryDetailsPathParameters) => {
  return `/product-catalog/api/v1/categories/history/${historyId}`;
};

export const getCategoryHistoryDetails = async (
  { historyId }: GetCategoryHistoryDetailsPathParameters,
  options?: RequestInit,
): Promise<ProductCatalogDomainDTOsCategoryTreeHistoryDetailDto> => {
  return gatewayServiceCustomFetch<ProductCatalogDomainDTOsCategoryTreeHistoryDetailDto>(
    getGetCategoryHistoryDetailsUrl({ historyId }),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetCategoryHistoryDetailsQueryKey = ({
  historyId,
}: GetCategoryHistoryDetailsPathParameters) => {
  return [
    "product-catalog",
    "api",
    "v1",
    "categories",
    "history",
    historyId,
  ] as const;
};

export const useGetCategoryHistoryDetailsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoryHistoryDetails>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { historyId }: GetCategoryHistoryDetailsPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetCategoryHistoryDetailsQueryKey({ historyId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCategoryHistoryDetails>>
  > = ({ signal }) =>
    getCategoryHistoryDetails({ historyId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoryHistoryDetailsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryHistoryDetails>>
>;
export type GetCategoryHistoryDetailsInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetCategoryHistoryDetailsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoryHistoryDetails>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetCategoryHistoryDetailsPathParameters,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
          TError,
          Awaited<ReturnType<typeof getCategoryHistoryDetails>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoryHistoryDetailsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoryHistoryDetails>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetCategoryHistoryDetailsPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
          TError,
          Awaited<ReturnType<typeof getCategoryHistoryDetails>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoryHistoryDetailsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoryHistoryDetails>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetCategoryHistoryDetailsPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get category history details
 */

export function useGetCategoryHistoryDetailsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoryHistoryDetails>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { historyId }: GetCategoryHistoryDetailsPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetCategoryHistoryDetailsInfiniteQueryOptions(
    { historyId },
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get category history details
 */
export const prefetchGetCategoryHistoryDetailsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { historyId }: GetCategoryHistoryDetailsPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetCategoryHistoryDetailsInfiniteQueryOptions(
    { historyId },
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetCategoryHistoryDetailsQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { historyId }: GetCategoryHistoryDetailsPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetCategoryHistoryDetailsQueryKey({ historyId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCategoryHistoryDetails>>
  > = ({ signal }) =>
    getCategoryHistoryDetails({ historyId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoryHistoryDetailsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryHistoryDetails>>
>;
export type GetCategoryHistoryDetailsQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetCategoryHistoryDetails<
  TData = Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetCategoryHistoryDetailsPathParameters,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
          TError,
          Awaited<ReturnType<typeof getCategoryHistoryDetails>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoryHistoryDetails<
  TData = Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetCategoryHistoryDetailsPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
          TError,
          Awaited<ReturnType<typeof getCategoryHistoryDetails>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoryHistoryDetails<
  TData = Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetCategoryHistoryDetailsPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get category history details
 */

export function useGetCategoryHistoryDetails<
  TData = Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { historyId }: GetCategoryHistoryDetailsPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetCategoryHistoryDetailsQueryOptions(
    { historyId },
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get category history details
 */
export const prefetchGetCategoryHistoryDetailsQuery = async <
  TData = Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { historyId }: GetCategoryHistoryDetailsPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryHistoryDetails>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetCategoryHistoryDetailsQueryOptions(
    { historyId },
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Upload or replace category image
 */
export const getUploadCategoryImageUrl = () => {
  return `/product-catalog/api/v1/categories/image`;
};

export const uploadCategoryImage = async (
  uploadCategoryImageBody: UploadCategoryImageBody,
  options?: RequestInit,
): Promise<ProductCatalogDomainDTOsCategoryImageUpdateResponse> => {
  const formData = new FormData();
  if (uploadCategoryImageBody.json !== undefined) {
    formData.append(`json`, JSON.stringify(uploadCategoryImageBody.json));
  }
  formData.append(`image`, uploadCategoryImageBody.image);

  return gatewayServiceCustomFetch<ProductCatalogDomainDTOsCategoryImageUpdateResponse>(
    getUploadCategoryImageUrl(),
    {
      ...options,
      method: "POST",
      body: formData,
    },
  );
};

export const getUploadCategoryImageMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadCategoryImage>>,
    TError,
    { data: UploadCategoryImageBody },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadCategoryImage>>,
  TError,
  { data: UploadCategoryImageBody },
  TContext
> => {
  const mutationKey = ["uploadCategoryImage"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadCategoryImage>>,
    { data: UploadCategoryImageBody }
  > = (props) => {
    const { data } = props ?? {};

    return uploadCategoryImage(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadCategoryImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadCategoryImage>>
>;
export type UploadCategoryImageMutationBody = UploadCategoryImageBody;
export type UploadCategoryImageMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Upload or replace category image
 */
export const useUploadCategoryImage = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadCategoryImage>>,
      TError,
      { data: UploadCategoryImageBody },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadCategoryImage>>,
  TError,
  { data: UploadCategoryImageBody },
  TContext
> => {
  const mutationOptions = getUploadCategoryImageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get signed URLs for category images
 */
export const getGetCategoryImageUrlsUrl = () => {
  return `/product-catalog/api/v1/categories/image-urls`;
};

export const getCategoryImageUrls = async (
  productCatalogDomainDTOsGetCategoryImageUrlsRequest: ProductCatalogDomainDTOsGetCategoryImageUrlsRequest,
  options?: RequestInit,
): Promise<ProductCatalogDomainDTOsCategoryImageUrlsResponse> => {
  return gatewayServiceCustomFetch<ProductCatalogDomainDTOsCategoryImageUrlsResponse>(
    getGetCategoryImageUrlsUrl(),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(productCatalogDomainDTOsGetCategoryImageUrlsRequest),
    },
  );
};

export const getGetCategoryImageUrlsMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getCategoryImageUrls>>,
    TError,
    { data: ProductCatalogDomainDTOsGetCategoryImageUrlsRequest },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getCategoryImageUrls>>,
  TError,
  { data: ProductCatalogDomainDTOsGetCategoryImageUrlsRequest },
  TContext
> => {
  const mutationKey = ["getCategoryImageUrls"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCategoryImageUrls>>,
    { data: ProductCatalogDomainDTOsGetCategoryImageUrlsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return getCategoryImageUrls(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetCategoryImageUrlsMutationResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryImageUrls>>
>;
export type GetCategoryImageUrlsMutationBody =
  ProductCatalogDomainDTOsGetCategoryImageUrlsRequest;
export type GetCategoryImageUrlsMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Get signed URLs for category images
 */
export const useGetCategoryImageUrls = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getCategoryImageUrls>>,
      TError,
      { data: ProductCatalogDomainDTOsGetCategoryImageUrlsRequest },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof getCategoryImageUrls>>,
  TError,
  { data: ProductCatalogDomainDTOsGetCategoryImageUrlsRequest },
  TContext
> => {
  const mutationOptions = getGetCategoryImageUrlsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Recover category tree to a historical state
 */
export const getRecoverToHistoricalStateUrl = () => {
  return `/product-catalog/api/v1/categories/recover`;
};

export const recoverToHistoricalState = async (
  productCatalogDomainDTOsRecoverToHistoricalStateRequest: ProductCatalogDomainDTOsRecoverToHistoricalStateRequest,
  options?: RequestInit,
): Promise<ProductCatalogDomainDTOsRecoveryResult> => {
  return gatewayServiceCustomFetch<ProductCatalogDomainDTOsRecoveryResult>(
    getRecoverToHistoricalStateUrl(),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        productCatalogDomainDTOsRecoverToHistoricalStateRequest,
      ),
    },
  );
};

export const getRecoverToHistoricalStateMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof recoverToHistoricalState>>,
    TError,
    { data: ProductCatalogDomainDTOsRecoverToHistoricalStateRequest },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof recoverToHistoricalState>>,
  TError,
  { data: ProductCatalogDomainDTOsRecoverToHistoricalStateRequest },
  TContext
> => {
  const mutationKey = ["recoverToHistoricalState"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof recoverToHistoricalState>>,
    { data: ProductCatalogDomainDTOsRecoverToHistoricalStateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return recoverToHistoricalState(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RecoverToHistoricalStateMutationResult = NonNullable<
  Awaited<ReturnType<typeof recoverToHistoricalState>>
>;
export type RecoverToHistoricalStateMutationBody =
  ProductCatalogDomainDTOsRecoverToHistoricalStateRequest;
export type RecoverToHistoricalStateMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Recover category tree to a historical state
 */
export const useRecoverToHistoricalState = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof recoverToHistoricalState>>,
      TError,
      { data: ProductCatalogDomainDTOsRecoverToHistoricalStateRequest },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof recoverToHistoricalState>>,
  TError,
  { data: ProductCatalogDomainDTOsRecoverToHistoricalStateRequest },
  TContext
> => {
  const mutationOptions = getRecoverToHistoricalStateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Search categories
 */
export const getSearchCategoriesUrl = () => {
  return `/product-catalog/api/v1/categories/search`;
};

export const searchCategories = async (
  productCatalogDomainDTOsCategorySearchRequest: ProductCatalogDomainDTOsCategorySearchRequest,
  options?: RequestInit,
): Promise<ProductCatalogDomainDTOsCategoryDto[]> => {
  return gatewayServiceCustomFetch<ProductCatalogDomainDTOsCategoryDto[]>(
    getSearchCategoriesUrl(),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(productCatalogDomainDTOsCategorySearchRequest),
    },
  );
};

export const getSearchCategoriesMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchCategories>>,
    TError,
    { data: ProductCatalogDomainDTOsCategorySearchRequest },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchCategories>>,
  TError,
  { data: ProductCatalogDomainDTOsCategorySearchRequest },
  TContext
> => {
  const mutationKey = ["searchCategories"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchCategories>>,
    { data: ProductCatalogDomainDTOsCategorySearchRequest }
  > = (props) => {
    const { data } = props ?? {};

    return searchCategories(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchCategoriesMutationResult = NonNullable<
  Awaited<ReturnType<typeof searchCategories>>
>;
export type SearchCategoriesMutationBody =
  ProductCatalogDomainDTOsCategorySearchRequest;
export type SearchCategoriesMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Search categories
 */
export const useSearchCategories = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof searchCategories>>,
      TError,
      { data: ProductCatalogDomainDTOsCategorySearchRequest },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof searchCategories>>,
  TError,
  { data: ProductCatalogDomainDTOsCategorySearchRequest },
  TContext
> => {
  const mutationOptions = getSearchCategoriesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
