/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * AuthService.API
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthServiceAPIControllersLinkExternalLoginRequest,
  AuthServiceAPIControllersRemoveExternalLoginRequest,
  AuthServiceAPIModelsResponsesExternalLoginResponse,
  AuthServiceAPIModelsResponsesExternalProviderResponse,
  ClicksiDataContractsCommonDtoApiResponse,
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  ExternalLoginParams,
  ExternalLoginPathParameters,
  HandleExternalLoginCallbackParams,
} from "../../types";

import { gatewayServiceCustomFetch } from "../../../../lib/orval/orval-fetch";
import { customQueryOptions } from "../../../../lib/orval/custom-query-options";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Handles the callback from the external provider
 */
export const getHandleExternalLoginCallbackUrl = (
  params?: HandleExternalLoginCallbackParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/auth/api/v1/external/callback?${stringifiedParams}`
    : `/auth/api/v1/external/callback`;
};

export const handleExternalLoginCallback = async (
  params?: HandleExternalLoginCallbackParams,
  options?: RequestInit,
): Promise<unknown> => {
  return gatewayServiceCustomFetch<unknown>(
    getHandleExternalLoginCallbackUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getHandleExternalLoginCallbackQueryKey = (
  params?: HandleExternalLoginCallbackParams,
) => {
  return [
    "auth",
    "api",
    "v1",
    "external",
    "callback",
    ...(params ? [params] : []),
  ] as const;
};

export const useHandleExternalLoginCallbackInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof handleExternalLoginCallback>>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: HandleExternalLoginCallbackParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getHandleExternalLoginCallbackQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof handleExternalLoginCallback>>
  > = ({ signal }) =>
    handleExternalLoginCallback(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof handleExternalLoginCallback>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HandleExternalLoginCallbackInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof handleExternalLoginCallback>>
>;
export type HandleExternalLoginCallbackInfiniteQueryError =
  void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useHandleExternalLoginCallbackInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof handleExternalLoginCallback>>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | HandleExternalLoginCallbackParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof handleExternalLoginCallback>>,
          TError,
          Awaited<ReturnType<typeof handleExternalLoginCallback>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHandleExternalLoginCallbackInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof handleExternalLoginCallback>>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: HandleExternalLoginCallbackParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof handleExternalLoginCallback>>,
          TError,
          Awaited<ReturnType<typeof handleExternalLoginCallback>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHandleExternalLoginCallbackInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof handleExternalLoginCallback>>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: HandleExternalLoginCallbackParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Handles the callback from the external provider
 */

export function useHandleExternalLoginCallbackInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof handleExternalLoginCallback>>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: HandleExternalLoginCallbackParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useHandleExternalLoginCallbackInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Handles the callback from the external provider
 */
export const prefetchHandleExternalLoginCallbackInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof handleExternalLoginCallback>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: HandleExternalLoginCallbackParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useHandleExternalLoginCallbackInfiniteQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useHandleExternalLoginCallbackQueryOptions = <
  TData = Awaited<ReturnType<typeof handleExternalLoginCallback>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: HandleExternalLoginCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getHandleExternalLoginCallbackQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof handleExternalLoginCallback>>
  > = ({ signal }) =>
    handleExternalLoginCallback(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof handleExternalLoginCallback>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HandleExternalLoginCallbackQueryResult = NonNullable<
  Awaited<ReturnType<typeof handleExternalLoginCallback>>
>;
export type HandleExternalLoginCallbackQueryError =
  void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useHandleExternalLoginCallback<
  TData = Awaited<ReturnType<typeof handleExternalLoginCallback>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | HandleExternalLoginCallbackParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof handleExternalLoginCallback>>,
          TError,
          Awaited<ReturnType<typeof handleExternalLoginCallback>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHandleExternalLoginCallback<
  TData = Awaited<ReturnType<typeof handleExternalLoginCallback>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: HandleExternalLoginCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof handleExternalLoginCallback>>,
          TError,
          Awaited<ReturnType<typeof handleExternalLoginCallback>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHandleExternalLoginCallback<
  TData = Awaited<ReturnType<typeof handleExternalLoginCallback>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: HandleExternalLoginCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Handles the callback from the external provider
 */

export function useHandleExternalLoginCallback<
  TData = Awaited<ReturnType<typeof handleExternalLoginCallback>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: HandleExternalLoginCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useHandleExternalLoginCallbackQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Handles the callback from the external provider
 */
export const prefetchHandleExternalLoginCallbackQuery = async <
  TData = Awaited<ReturnType<typeof handleExternalLoginCallback>>,
  TError = void | ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: HandleExternalLoginCallbackParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof handleExternalLoginCallback>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useHandleExternalLoginCallbackQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Links an external login to an existing user account
 */
export const getLinkExternalLoginUrl = () => {
  return `/auth/api/v1/external/link`;
};

export const linkExternalLogin = async (
  authServiceAPIControllersLinkExternalLoginRequest: AuthServiceAPIControllersLinkExternalLoginRequest,
  options?: RequestInit,
): Promise<ClicksiDataContractsCommonDtoApiResponse> => {
  return gatewayServiceCustomFetch<ClicksiDataContractsCommonDtoApiResponse>(
    getLinkExternalLoginUrl(),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(authServiceAPIControllersLinkExternalLoginRequest),
    },
  );
};

export const getLinkExternalLoginMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof linkExternalLogin>>,
    TError,
    { data: AuthServiceAPIControllersLinkExternalLoginRequest },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof linkExternalLogin>>,
  TError,
  { data: AuthServiceAPIControllersLinkExternalLoginRequest },
  TContext
> => {
  const mutationKey = ["linkExternalLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof linkExternalLogin>>,
    { data: AuthServiceAPIControllersLinkExternalLoginRequest }
  > = (props) => {
    const { data } = props ?? {};

    return linkExternalLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LinkExternalLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof linkExternalLogin>>
>;
export type LinkExternalLoginMutationBody =
  AuthServiceAPIControllersLinkExternalLoginRequest;
export type LinkExternalLoginMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Links an external login to an existing user account
 */
export const useLinkExternalLogin = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof linkExternalLogin>>,
      TError,
      { data: AuthServiceAPIControllersLinkExternalLoginRequest },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof linkExternalLogin>>,
  TError,
  { data: AuthServiceAPIControllersLinkExternalLoginRequest },
  TContext
> => {
  const mutationOptions = getLinkExternalLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Removes an external login from a user account
 */
export const getRemoveExternalLoginUrl = () => {
  return `/auth/api/v1/external/link/remove`;
};

export const removeExternalLogin = async (
  authServiceAPIControllersRemoveExternalLoginRequest: AuthServiceAPIControllersRemoveExternalLoginRequest,
  options?: RequestInit,
): Promise<ClicksiDataContractsCommonDtoApiResponse> => {
  return gatewayServiceCustomFetch<ClicksiDataContractsCommonDtoApiResponse>(
    getRemoveExternalLoginUrl(),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(authServiceAPIControllersRemoveExternalLoginRequest),
    },
  );
};

export const getRemoveExternalLoginMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeExternalLogin>>,
    TError,
    { data: AuthServiceAPIControllersRemoveExternalLoginRequest },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeExternalLogin>>,
  TError,
  { data: AuthServiceAPIControllersRemoveExternalLoginRequest },
  TContext
> => {
  const mutationKey = ["removeExternalLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeExternalLogin>>,
    { data: AuthServiceAPIControllersRemoveExternalLoginRequest }
  > = (props) => {
    const { data } = props ?? {};

    return removeExternalLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveExternalLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeExternalLogin>>
>;
export type RemoveExternalLoginMutationBody =
  AuthServiceAPIControllersRemoveExternalLoginRequest;
export type RemoveExternalLoginMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Removes an external login from a user account
 */
export const useRemoveExternalLogin = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeExternalLogin>>,
      TError,
      { data: AuthServiceAPIControllersRemoveExternalLoginRequest },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeExternalLogin>>,
  TError,
  { data: AuthServiceAPIControllersRemoveExternalLoginRequest },
  TContext
> => {
  const mutationOptions = getRemoveExternalLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Initiates external login flow
 */
export const getExternalLoginUrl = (
  { provider }: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/auth/api/v1/external/login/${provider}?${stringifiedParams}`
    : `/auth/api/v1/external/login/${provider}`;
};

export const externalLogin = async (
  { provider }: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: RequestInit,
): Promise<void> => {
  return gatewayServiceCustomFetch<void>(
    getExternalLoginUrl({ provider }, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getExternalLoginQueryKey = (
  { provider }: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
) => {
  return [
    "auth",
    "api",
    "v1",
    "external",
    "login",
    provider,
    ...(params ? [params] : []),
  ] as const;
};

export const useExternalLoginInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof externalLogin>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { provider }: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof externalLogin>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getExternalLoginQueryKey({ provider }, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof externalLogin>>> = ({
    signal,
  }) => externalLogin({ provider }, params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof externalLogin>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ExternalLoginInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof externalLogin>>
>;
export type ExternalLoginInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useExternalLoginInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof externalLogin>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: ExternalLoginPathParameters,
  params: undefined | ExternalLoginParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof externalLogin>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof externalLogin>>,
          TError,
          Awaited<ReturnType<typeof externalLogin>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExternalLoginInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof externalLogin>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof externalLogin>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof externalLogin>>,
          TError,
          Awaited<ReturnType<typeof externalLogin>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExternalLoginInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof externalLogin>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof externalLogin>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Initiates external login flow
 */

export function useExternalLoginInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof externalLogin>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { provider }: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof externalLogin>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useExternalLoginInfiniteQueryOptions(
    { provider },
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Initiates external login flow
 */
export const prefetchExternalLoginInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof externalLogin>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { provider }: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof externalLogin>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useExternalLoginInfiniteQueryOptions(
    { provider },
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useExternalLoginQueryOptions = <
  TData = Awaited<ReturnType<typeof externalLogin>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { provider }: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof externalLogin>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getExternalLoginQueryKey({ provider }, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof externalLogin>>> = ({
    signal,
  }) => externalLogin({ provider }, params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof externalLogin>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ExternalLoginQueryResult = NonNullable<
  Awaited<ReturnType<typeof externalLogin>>
>;
export type ExternalLoginQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useExternalLogin<
  TData = Awaited<ReturnType<typeof externalLogin>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: ExternalLoginPathParameters,
  params: undefined | ExternalLoginParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof externalLogin>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof externalLogin>>,
          TError,
          Awaited<ReturnType<typeof externalLogin>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExternalLogin<
  TData = Awaited<ReturnType<typeof externalLogin>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof externalLogin>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof externalLogin>>,
          TError,
          Awaited<ReturnType<typeof externalLogin>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExternalLogin<
  TData = Awaited<ReturnType<typeof externalLogin>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof externalLogin>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Initiates external login flow
 */

export function useExternalLogin<
  TData = Awaited<ReturnType<typeof externalLogin>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { provider }: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof externalLogin>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useExternalLoginQueryOptions(
    { provider },
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Initiates external login flow
 */
export const prefetchExternalLoginQuery = async <
  TData = Awaited<ReturnType<typeof externalLogin>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { provider }: ExternalLoginPathParameters,
  params?: ExternalLoginParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof externalLogin>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useExternalLoginQueryOptions(
    { provider },
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Gets external logins for the current user
 */
export const getGetExternalLoginsUrl = () => {
  return `/auth/api/v1/external/logins`;
};

export const getExternalLogins = async (
  options?: RequestInit,
): Promise<AuthServiceAPIModelsResponsesExternalLoginResponse[]> => {
  return gatewayServiceCustomFetch<
    AuthServiceAPIModelsResponsesExternalLoginResponse[]
  >(getGetExternalLoginsUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetExternalLoginsQueryKey = () => {
  return ["auth", "api", "v1", "external", "logins"] as const;
};

export const useGetExternalLoginsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getExternalLogins>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getExternalLogins>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExternalLoginsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExternalLogins>>
  > = ({ signal }) => getExternalLogins({ signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getExternalLogins>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExternalLoginsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExternalLogins>>
>;
export type GetExternalLoginsInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetExternalLoginsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExternalLogins>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExternalLogins>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExternalLogins>>,
          TError,
          Awaited<ReturnType<typeof getExternalLogins>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExternalLoginsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExternalLogins>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExternalLogins>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExternalLogins>>,
          TError,
          Awaited<ReturnType<typeof getExternalLogins>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExternalLoginsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExternalLogins>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExternalLogins>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets external logins for the current user
 */

export function useGetExternalLoginsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExternalLogins>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExternalLogins>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetExternalLoginsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets external logins for the current user
 */
export const prefetchGetExternalLoginsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getExternalLogins>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExternalLogins>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetExternalLoginsInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetExternalLoginsQueryOptions = <
  TData = Awaited<ReturnType<typeof getExternalLogins>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getExternalLogins>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExternalLoginsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExternalLogins>>
  > = ({ signal }) => getExternalLogins({ signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getExternalLogins>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExternalLoginsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExternalLogins>>
>;
export type GetExternalLoginsQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetExternalLogins<
  TData = Awaited<ReturnType<typeof getExternalLogins>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalLogins>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExternalLogins>>,
          TError,
          Awaited<ReturnType<typeof getExternalLogins>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExternalLogins<
  TData = Awaited<ReturnType<typeof getExternalLogins>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalLogins>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExternalLogins>>,
          TError,
          Awaited<ReturnType<typeof getExternalLogins>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExternalLogins<
  TData = Awaited<ReturnType<typeof getExternalLogins>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalLogins>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets external logins for the current user
 */

export function useGetExternalLogins<
  TData = Awaited<ReturnType<typeof getExternalLogins>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalLogins>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetExternalLoginsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets external logins for the current user
 */
export const prefetchGetExternalLoginsQuery = async <
  TData = Awaited<ReturnType<typeof getExternalLogins>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalLogins>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetExternalLoginsQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Get available external authentication providers
 */
export const getGetExternalProvidersUrl = () => {
  return `/auth/api/v1/external/providers`;
};

export const getExternalProviders = async (
  options?: RequestInit,
): Promise<AuthServiceAPIModelsResponsesExternalProviderResponse[]> => {
  return gatewayServiceCustomFetch<
    AuthServiceAPIModelsResponsesExternalProviderResponse[]
  >(getGetExternalProvidersUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetExternalProvidersQueryKey = () => {
  return ["auth", "api", "v1", "external", "providers"] as const;
};

export const useGetExternalProvidersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getExternalProviders>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getExternalProviders>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExternalProvidersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExternalProviders>>
  > = ({ signal }) => getExternalProviders({ signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getExternalProviders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExternalProvidersInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExternalProviders>>
>;
export type GetExternalProvidersInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetExternalProvidersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExternalProviders>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExternalProviders>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExternalProviders>>,
          TError,
          Awaited<ReturnType<typeof getExternalProviders>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExternalProvidersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExternalProviders>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExternalProviders>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExternalProviders>>,
          TError,
          Awaited<ReturnType<typeof getExternalProviders>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExternalProvidersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExternalProviders>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExternalProviders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get available external authentication providers
 */

export function useGetExternalProvidersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExternalProviders>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExternalProviders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetExternalProvidersInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get available external authentication providers
 */
export const prefetchGetExternalProvidersInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getExternalProviders>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExternalProviders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetExternalProvidersInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetExternalProvidersQueryOptions = <
  TData = Awaited<ReturnType<typeof getExternalProviders>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getExternalProviders>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExternalProvidersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExternalProviders>>
  > = ({ signal }) => getExternalProviders({ signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getExternalProviders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExternalProvidersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExternalProviders>>
>;
export type GetExternalProvidersQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetExternalProviders<
  TData = Awaited<ReturnType<typeof getExternalProviders>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalProviders>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExternalProviders>>,
          TError,
          Awaited<ReturnType<typeof getExternalProviders>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExternalProviders<
  TData = Awaited<ReturnType<typeof getExternalProviders>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalProviders>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExternalProviders>>,
          TError,
          Awaited<ReturnType<typeof getExternalProviders>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExternalProviders<
  TData = Awaited<ReturnType<typeof getExternalProviders>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalProviders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get available external authentication providers
 */

export function useGetExternalProviders<
  TData = Awaited<ReturnType<typeof getExternalProviders>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalProviders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetExternalProvidersQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get available external authentication providers
 */
export const prefetchGetExternalProvidersQuery = async <
  TData = Awaited<ReturnType<typeof getExternalProviders>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExternalProviders>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetExternalProvidersQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};
