/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * UserManagement.API
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  ActivateSubscriptionPathParameters,
  ClicksiDataContractsCommonDtoApiResponse,
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  GetSubscriptionParams,
  GetSubscriptionPathParameters,
  GetTeamActiveSubscriptionPathParameters,
  GetTeamSubscriptionsParams,
  GetTeamSubscriptionsPathParameters,
  GetUserTeamSubscriptionsParams,
  SuspendSubscriptionPathParameters,
  UserManagementAPIControllersActivateSubscriptionRequest,
  UserManagementAPIControllersSuspendSubscriptionRequest,
  UserManagementDomainDTOsCancelSubscriptionRequest,
  UserManagementDomainDTOsCreateSubscriptionRequest,
  UserManagementDomainDTOsTeamSubscriptionDto,
  UserManagementDomainDTOsUpdateSubscriptionRequest,
} from "../../types";

import { gatewayServiceCustomFetch } from "../../../../lib/orval/orval-fetch";
import { customQueryOptions } from "../../../../lib/orval/custom-query-options";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Create new team subscription
 */
export const getCreateSubscriptionUrl = () => {
  return `/user-management/api/v1/subscriptions`;
};

export const createSubscription = async (
  userManagementDomainDTOsCreateSubscriptionRequest: UserManagementDomainDTOsCreateSubscriptionRequest,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsTeamSubscriptionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsTeamSubscriptionDto>(
    getCreateSubscriptionUrl(),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(userManagementDomainDTOsCreateSubscriptionRequest),
    },
  );
};

export const getCreateSubscriptionMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSubscription>>,
    TError,
    { data: UserManagementDomainDTOsCreateSubscriptionRequest },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSubscription>>,
  TError,
  { data: UserManagementDomainDTOsCreateSubscriptionRequest },
  TContext
> => {
  const mutationKey = ["createSubscription"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSubscription>>,
    { data: UserManagementDomainDTOsCreateSubscriptionRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createSubscription(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSubscription>>
>;
export type CreateSubscriptionMutationBody =
  UserManagementDomainDTOsCreateSubscriptionRequest;
export type CreateSubscriptionMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Create new team subscription
 */
export const useCreateSubscription = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSubscription>>,
      TError,
      { data: UserManagementDomainDTOsCreateSubscriptionRequest },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createSubscription>>,
  TError,
  { data: UserManagementDomainDTOsCreateSubscriptionRequest },
  TContext
> => {
  const mutationOptions = getCreateSubscriptionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Update subscription
 */
export const getUpdateSubscriptionUrl = () => {
  return `/user-management/api/v1/subscriptions`;
};

export const updateSubscription = async (
  userManagementDomainDTOsUpdateSubscriptionRequest: UserManagementDomainDTOsUpdateSubscriptionRequest,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsTeamSubscriptionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsTeamSubscriptionDto>(
    getUpdateSubscriptionUrl(),
    {
      ...options,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(userManagementDomainDTOsUpdateSubscriptionRequest),
    },
  );
};

export const getUpdateSubscriptionMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSubscription>>,
    TError,
    { data: UserManagementDomainDTOsUpdateSubscriptionRequest },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSubscription>>,
  TError,
  { data: UserManagementDomainDTOsUpdateSubscriptionRequest },
  TContext
> => {
  const mutationKey = ["updateSubscription"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSubscription>>,
    { data: UserManagementDomainDTOsUpdateSubscriptionRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateSubscription(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSubscription>>
>;
export type UpdateSubscriptionMutationBody =
  UserManagementDomainDTOsUpdateSubscriptionRequest;
export type UpdateSubscriptionMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Update subscription
 */
export const useUpdateSubscription = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSubscription>>,
      TError,
      { data: UserManagementDomainDTOsUpdateSubscriptionRequest },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateSubscription>>,
  TError,
  { data: UserManagementDomainDTOsUpdateSubscriptionRequest },
  TContext
> => {
  const mutationOptions = getUpdateSubscriptionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get subscription by ID
 */
export const getGetSubscriptionUrl = (
  { subscriptionId }: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/user-management/api/v1/subscriptions/${subscriptionId}?${stringifiedParams}`
    : `/user-management/api/v1/subscriptions/${subscriptionId}`;
};

export const getSubscription = async (
  { subscriptionId }: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsTeamSubscriptionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsTeamSubscriptionDto>(
    getGetSubscriptionUrl({ subscriptionId }, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetSubscriptionQueryKey = (
  { subscriptionId }: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
) => {
  return [
    "user-management",
    "api",
    "v1",
    "subscriptions",
    subscriptionId,
    ...(params ? [params] : []),
  ] as const;
};

export const useGetSubscriptionInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSubscription>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { subscriptionId }: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSubscriptionQueryKey({ subscriptionId }, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubscription>>> = ({
    signal,
  }) =>
    getSubscription({ subscriptionId }, params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSubscription>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSubscriptionInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubscription>>
>;
export type GetSubscriptionInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetSubscriptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubscription>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetSubscriptionPathParameters,
  params: undefined | GetSubscriptionParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubscription>>,
          TError,
          Awaited<ReturnType<typeof getSubscription>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubscriptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubscription>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubscription>>,
          TError,
          Awaited<ReturnType<typeof getSubscription>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubscriptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubscription>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get subscription by ID
 */

export function useGetSubscriptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubscription>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { subscriptionId }: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetSubscriptionInfiniteQueryOptions(
    { subscriptionId },
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get subscription by ID
 */
export const prefetchGetSubscriptionInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { subscriptionId }: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetSubscriptionInfiniteQueryOptions(
    { subscriptionId },
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetSubscriptionQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { subscriptionId }: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSubscriptionQueryKey({ subscriptionId }, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubscription>>> = ({
    signal,
  }) =>
    getSubscription({ subscriptionId }, params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getSubscription>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSubscriptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubscription>>
>;
export type GetSubscriptionQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetSubscription<
  TData = Awaited<ReturnType<typeof getSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetSubscriptionPathParameters,
  params: undefined | GetSubscriptionParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubscription>>,
          TError,
          Awaited<ReturnType<typeof getSubscription>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubscription<
  TData = Awaited<ReturnType<typeof getSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubscription>>,
          TError,
          Awaited<ReturnType<typeof getSubscription>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubscription<
  TData = Awaited<ReturnType<typeof getSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get subscription by ID
 */

export function useGetSubscription<
  TData = Awaited<ReturnType<typeof getSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { subscriptionId }: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetSubscriptionQueryOptions(
    { subscriptionId },
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get subscription by ID
 */
export const prefetchGetSubscriptionQuery = async <
  TData = Awaited<ReturnType<typeof getSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { subscriptionId }: GetSubscriptionPathParameters,
  params?: GetSubscriptionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetSubscriptionQueryOptions(
    { subscriptionId },
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Activate subscription (Payment webhook)
 */
export const getActivateSubscriptionUrl = ({
  subscriptionId,
}: ActivateSubscriptionPathParameters) => {
  return `/user-management/api/v1/subscriptions/${subscriptionId}/activate`;
};

export const activateSubscription = async (
  { subscriptionId }: ActivateSubscriptionPathParameters,
  userManagementAPIControllersActivateSubscriptionRequest: UserManagementAPIControllersActivateSubscriptionRequest,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsTeamSubscriptionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsTeamSubscriptionDto>(
    getActivateSubscriptionUrl({ subscriptionId }),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        userManagementAPIControllersActivateSubscriptionRequest,
      ),
    },
  );
};

export const getActivateSubscriptionMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof activateSubscription>>,
    TError,
    {
      pathParams: ActivateSubscriptionPathParameters;
      data: UserManagementAPIControllersActivateSubscriptionRequest;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof activateSubscription>>,
  TError,
  {
    pathParams: ActivateSubscriptionPathParameters;
    data: UserManagementAPIControllersActivateSubscriptionRequest;
  },
  TContext
> => {
  const mutationKey = ["activateSubscription"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof activateSubscription>>,
    {
      pathParams: ActivateSubscriptionPathParameters;
      data: UserManagementAPIControllersActivateSubscriptionRequest;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return activateSubscription(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ActivateSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof activateSubscription>>
>;
export type ActivateSubscriptionMutationBody =
  UserManagementAPIControllersActivateSubscriptionRequest;
export type ActivateSubscriptionMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Activate subscription (Payment webhook)
 */
export const useActivateSubscription = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof activateSubscription>>,
      TError,
      {
        pathParams: ActivateSubscriptionPathParameters;
        data: UserManagementAPIControllersActivateSubscriptionRequest;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof activateSubscription>>,
  TError,
  {
    pathParams: ActivateSubscriptionPathParameters;
    data: UserManagementAPIControllersActivateSubscriptionRequest;
  },
  TContext
> => {
  const mutationOptions = getActivateSubscriptionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Suspend subscription (Admin only)
 */
export const getSuspendSubscriptionUrl = ({
  subscriptionId,
}: SuspendSubscriptionPathParameters) => {
  return `/user-management/api/v1/subscriptions/${subscriptionId}/suspend`;
};

export const suspendSubscription = async (
  { subscriptionId }: SuspendSubscriptionPathParameters,
  userManagementAPIControllersSuspendSubscriptionRequest: UserManagementAPIControllersSuspendSubscriptionRequest,
  options?: RequestInit,
): Promise<ClicksiDataContractsCommonDtoApiResponse> => {
  return gatewayServiceCustomFetch<ClicksiDataContractsCommonDtoApiResponse>(
    getSuspendSubscriptionUrl({ subscriptionId }),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        userManagementAPIControllersSuspendSubscriptionRequest,
      ),
    },
  );
};

export const getSuspendSubscriptionMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof suspendSubscription>>,
    TError,
    {
      pathParams: SuspendSubscriptionPathParameters;
      data: UserManagementAPIControllersSuspendSubscriptionRequest;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof suspendSubscription>>,
  TError,
  {
    pathParams: SuspendSubscriptionPathParameters;
    data: UserManagementAPIControllersSuspendSubscriptionRequest;
  },
  TContext
> => {
  const mutationKey = ["suspendSubscription"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof suspendSubscription>>,
    {
      pathParams: SuspendSubscriptionPathParameters;
      data: UserManagementAPIControllersSuspendSubscriptionRequest;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return suspendSubscription(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SuspendSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof suspendSubscription>>
>;
export type SuspendSubscriptionMutationBody =
  UserManagementAPIControllersSuspendSubscriptionRequest;
export type SuspendSubscriptionMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Suspend subscription (Admin only)
 */
export const useSuspendSubscription = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof suspendSubscription>>,
      TError,
      {
        pathParams: SuspendSubscriptionPathParameters;
        data: UserManagementAPIControllersSuspendSubscriptionRequest;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof suspendSubscription>>,
  TError,
  {
    pathParams: SuspendSubscriptionPathParameters;
    data: UserManagementAPIControllersSuspendSubscriptionRequest;
  },
  TContext
> => {
  const mutationOptions = getSuspendSubscriptionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Cancel subscription
 */
export const getCancelSubscriptionUrl = () => {
  return `/user-management/api/v1/subscriptions/cancel`;
};

export const cancelSubscription = async (
  userManagementDomainDTOsCancelSubscriptionRequest: UserManagementDomainDTOsCancelSubscriptionRequest,
  options?: RequestInit,
): Promise<ClicksiDataContractsCommonDtoApiResponse> => {
  return gatewayServiceCustomFetch<ClicksiDataContractsCommonDtoApiResponse>(
    getCancelSubscriptionUrl(),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(userManagementDomainDTOsCancelSubscriptionRequest),
    },
  );
};

export const getCancelSubscriptionMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelSubscription>>,
    TError,
    { data: UserManagementDomainDTOsCancelSubscriptionRequest },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelSubscription>>,
  TError,
  { data: UserManagementDomainDTOsCancelSubscriptionRequest },
  TContext
> => {
  const mutationKey = ["cancelSubscription"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelSubscription>>,
    { data: UserManagementDomainDTOsCancelSubscriptionRequest }
  > = (props) => {
    const { data } = props ?? {};

    return cancelSubscription(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelSubscription>>
>;
export type CancelSubscriptionMutationBody =
  UserManagementDomainDTOsCancelSubscriptionRequest;
export type CancelSubscriptionMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Cancel subscription
 */
export const useCancelSubscription = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancelSubscription>>,
      TError,
      { data: UserManagementDomainDTOsCancelSubscriptionRequest },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof cancelSubscription>>,
  TError,
  { data: UserManagementDomainDTOsCancelSubscriptionRequest },
  TContext
> => {
  const mutationOptions = getCancelSubscriptionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get team subscriptions
 */
export const getGetTeamSubscriptionsUrl = (
  { teamId }: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/user-management/api/v1/subscriptions/team/${teamId}?${stringifiedParams}`
    : `/user-management/api/v1/subscriptions/team/${teamId}`;
};

export const getTeamSubscriptions = async (
  { teamId }: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsTeamSubscriptionDto[]> => {
  return gatewayServiceCustomFetch<
    UserManagementDomainDTOsTeamSubscriptionDto[]
  >(getGetTeamSubscriptionsUrl({ teamId }, params), {
    ...options,
    method: "GET",
  });
};

export const getGetTeamSubscriptionsQueryKey = (
  { teamId }: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
) => {
  return [
    "user-management",
    "api",
    "v1",
    "subscriptions",
    "team",
    teamId,
    ...(params ? [params] : []),
  ] as const;
};

export const useGetTeamSubscriptionsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTeamSubscriptions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetTeamSubscriptionsQueryKey({ teamId }, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamSubscriptions>>
  > = ({ signal }) =>
    getTeamSubscriptions({ teamId }, params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTeamSubscriptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamSubscriptionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamSubscriptions>>
>;
export type GetTeamSubscriptionsInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetTeamSubscriptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTeamSubscriptions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamSubscriptionsPathParameters,
  params: undefined | GetTeamSubscriptionsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamSubscriptions>>,
          TError,
          Awaited<ReturnType<typeof getTeamSubscriptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamSubscriptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTeamSubscriptions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamSubscriptions>>,
          TError,
          Awaited<ReturnType<typeof getTeamSubscriptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamSubscriptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTeamSubscriptions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get team subscriptions
 */

export function useGetTeamSubscriptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTeamSubscriptions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetTeamSubscriptionsInfiniteQueryOptions(
    { teamId },
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get team subscriptions
 */
export const prefetchGetTeamSubscriptionsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { teamId }: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetTeamSubscriptionsInfiniteQueryOptions(
    { teamId },
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetTeamSubscriptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetTeamSubscriptionsQueryKey({ teamId }, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamSubscriptions>>
  > = ({ signal }) =>
    getTeamSubscriptions({ teamId }, params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamSubscriptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamSubscriptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamSubscriptions>>
>;
export type GetTeamSubscriptionsQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetTeamSubscriptions<
  TData = Awaited<ReturnType<typeof getTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamSubscriptionsPathParameters,
  params: undefined | GetTeamSubscriptionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamSubscriptions>>,
          TError,
          Awaited<ReturnType<typeof getTeamSubscriptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamSubscriptions<
  TData = Awaited<ReturnType<typeof getTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamSubscriptions>>,
          TError,
          Awaited<ReturnType<typeof getTeamSubscriptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamSubscriptions<
  TData = Awaited<ReturnType<typeof getTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get team subscriptions
 */

export function useGetTeamSubscriptions<
  TData = Awaited<ReturnType<typeof getTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetTeamSubscriptionsQueryOptions(
    { teamId },
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get team subscriptions
 */
export const prefetchGetTeamSubscriptionsQuery = async <
  TData = Awaited<ReturnType<typeof getTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { teamId }: GetTeamSubscriptionsPathParameters,
  params?: GetTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetTeamSubscriptionsQueryOptions(
    { teamId },
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Get team active subscription
 */
export const getGetTeamActiveSubscriptionUrl = ({
  teamId,
}: GetTeamActiveSubscriptionPathParameters) => {
  return `/user-management/api/v1/subscriptions/team/${teamId}/active`;
};

export const getTeamActiveSubscription = async (
  { teamId }: GetTeamActiveSubscriptionPathParameters,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsTeamSubscriptionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsTeamSubscriptionDto>(
    getGetTeamActiveSubscriptionUrl({ teamId }),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetTeamActiveSubscriptionQueryKey = ({
  teamId,
}: GetTeamActiveSubscriptionPathParameters) => {
  return [
    "user-management",
    "api",
    "v1",
    "subscriptions",
    "team",
    teamId,
    "active",
  ] as const;
};

export const useGetTeamActiveSubscriptionInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTeamActiveSubscription>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetTeamActiveSubscriptionPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTeamActiveSubscriptionQueryKey({ teamId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamActiveSubscription>>
  > = ({ signal }) =>
    getTeamActiveSubscription({ teamId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTeamActiveSubscription>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamActiveSubscriptionInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamActiveSubscription>>
>;
export type GetTeamActiveSubscriptionInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetTeamActiveSubscriptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTeamActiveSubscription>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamActiveSubscriptionPathParameters,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamActiveSubscription>>,
          TError,
          Awaited<ReturnType<typeof getTeamActiveSubscription>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamActiveSubscriptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTeamActiveSubscription>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamActiveSubscriptionPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamActiveSubscription>>,
          TError,
          Awaited<ReturnType<typeof getTeamActiveSubscription>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamActiveSubscriptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTeamActiveSubscription>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamActiveSubscriptionPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get team active subscription
 */

export function useGetTeamActiveSubscriptionInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTeamActiveSubscription>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetTeamActiveSubscriptionPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetTeamActiveSubscriptionInfiniteQueryOptions(
    { teamId },
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get team active subscription
 */
export const prefetchGetTeamActiveSubscriptionInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getTeamActiveSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { teamId }: GetTeamActiveSubscriptionPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetTeamActiveSubscriptionInfiniteQueryOptions(
    { teamId },
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetTeamActiveSubscriptionQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeamActiveSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetTeamActiveSubscriptionPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTeamActiveSubscriptionQueryKey({ teamId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTeamActiveSubscription>>
  > = ({ signal }) =>
    getTeamActiveSubscription({ teamId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getTeamActiveSubscription>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTeamActiveSubscriptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeamActiveSubscription>>
>;
export type GetTeamActiveSubscriptionQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetTeamActiveSubscription<
  TData = Awaited<ReturnType<typeof getTeamActiveSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamActiveSubscriptionPathParameters,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamActiveSubscription>>,
          TError,
          Awaited<ReturnType<typeof getTeamActiveSubscription>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamActiveSubscription<
  TData = Awaited<ReturnType<typeof getTeamActiveSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamActiveSubscriptionPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeamActiveSubscription>>,
          TError,
          Awaited<ReturnType<typeof getTeamActiveSubscription>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeamActiveSubscription<
  TData = Awaited<ReturnType<typeof getTeamActiveSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetTeamActiveSubscriptionPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get team active subscription
 */

export function useGetTeamActiveSubscription<
  TData = Awaited<ReturnType<typeof getTeamActiveSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetTeamActiveSubscriptionPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetTeamActiveSubscriptionQueryOptions(
    { teamId },
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get team active subscription
 */
export const prefetchGetTeamActiveSubscriptionQuery = async <
  TData = Awaited<ReturnType<typeof getTeamActiveSubscription>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { teamId }: GetTeamActiveSubscriptionPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTeamActiveSubscription>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetTeamActiveSubscriptionQueryOptions(
    { teamId },
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Get user's team subscriptions (returns all subscriptions for teams the user belongs to)
 */
export const getGetUserTeamSubscriptionsUrl = (
  params?: GetUserTeamSubscriptionsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/user-management/api/v1/subscriptions/user/teams?${stringifiedParams}`
    : `/user-management/api/v1/subscriptions/user/teams`;
};

export const getUserTeamSubscriptions = async (
  params?: GetUserTeamSubscriptionsParams,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsTeamSubscriptionDto[]> => {
  return gatewayServiceCustomFetch<
    UserManagementDomainDTOsTeamSubscriptionDto[]
  >(getGetUserTeamSubscriptionsUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetUserTeamSubscriptionsQueryKey = (
  params?: GetUserTeamSubscriptionsParams,
) => {
  return [
    "user-management",
    "api",
    "v1",
    "subscriptions",
    "user",
    "teams",
    ...(params ? [params] : []),
  ] as const;
};

export const useGetUserTeamSubscriptionsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUserTeamSubscriptions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetUserTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserTeamSubscriptionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserTeamSubscriptions>>
  > = ({ signal }) =>
    getUserTeamSubscriptions(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserTeamSubscriptionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserTeamSubscriptions>>
>;
export type GetUserTeamSubscriptionsInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetUserTeamSubscriptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserTeamSubscriptions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetUserTeamSubscriptionsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
          TError,
          Awaited<ReturnType<typeof getUserTeamSubscriptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserTeamSubscriptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserTeamSubscriptions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetUserTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
          TError,
          Awaited<ReturnType<typeof getUserTeamSubscriptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserTeamSubscriptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserTeamSubscriptions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetUserTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's team subscriptions (returns all subscriptions for teams the user belongs to)
 */

export function useGetUserTeamSubscriptionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserTeamSubscriptions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetUserTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetUserTeamSubscriptionsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get user's team subscriptions (returns all subscriptions for teams the user belongs to)
 */
export const prefetchGetUserTeamSubscriptionsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetUserTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetUserTeamSubscriptionsInfiniteQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetUserTeamSubscriptionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetUserTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserTeamSubscriptionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserTeamSubscriptions>>
  > = ({ signal }) =>
    getUserTeamSubscriptions(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserTeamSubscriptionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserTeamSubscriptions>>
>;
export type GetUserTeamSubscriptionsQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetUserTeamSubscriptions<
  TData = Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetUserTeamSubscriptionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
          TError,
          Awaited<ReturnType<typeof getUserTeamSubscriptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserTeamSubscriptions<
  TData = Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetUserTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
          TError,
          Awaited<ReturnType<typeof getUserTeamSubscriptions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserTeamSubscriptions<
  TData = Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetUserTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user's team subscriptions (returns all subscriptions for teams the user belongs to)
 */

export function useGetUserTeamSubscriptions<
  TData = Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetUserTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetUserTeamSubscriptionsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get user's team subscriptions (returns all subscriptions for teams the user belongs to)
 */
export const prefetchGetUserTeamSubscriptionsQuery = async <
  TData = Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetUserTeamSubscriptionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserTeamSubscriptions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetUserTeamSubscriptionsQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};
