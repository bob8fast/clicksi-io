/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * UserManagement.API
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  ApprovePartnerConnectionPathParameters,
  ClicksiDataContractsCommonModelsResponsesPagedResponse1UserManagementDomainDTOsPartnerConnectionDto,
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  GetMyTeamsPartnerConnectionsParams,
  GetPartnerConnectionByIdPathParameters,
  GetPartnerConnectionsByTeamParams,
  GetPartnerConnectionsByTeamPathParameters,
  GetPendingPartnerConnectionsForTeamPathParameters,
  RejectPartnerConnectionPathParameters,
  SearchPartnerConnectionsParams,
  TerminatePartnerConnectionPathParameters,
  UpdatePartnerConnectionPathParameters,
  UserManagementAPIModelsRequestsApprovePartnerConnectionRequest,
  UserManagementAPIModelsRequestsCreatePartnerConnectionRequest,
  UserManagementAPIModelsRequestsRejectPartnerConnectionRequest,
  UserManagementAPIModelsRequestsTerminatePartnerConnectionRequest,
  UserManagementAPIModelsRequestsUpdatePartnerConnectionRequest,
  UserManagementDomainDTOsPartnerConnectionDto,
} from "../../types";

import { gatewayServiceCustomFetch } from "../../../../lib/orval/orval-fetch";
import { customQueryOptions } from "../../../../lib/orval/custom-query-options";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Creates a new partner connection request
 */
export const getCreatePartnerConnectionUrl = () => {
  return `/user-management/api/v1/partner-connections`;
};

export const createPartnerConnection = async (
  userManagementAPIModelsRequestsCreatePartnerConnectionRequest: UserManagementAPIModelsRequestsCreatePartnerConnectionRequest,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsPartnerConnectionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsPartnerConnectionDto>(
    getCreatePartnerConnectionUrl(),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        userManagementAPIModelsRequestsCreatePartnerConnectionRequest,
      ),
    },
  );
};

export const getCreatePartnerConnectionMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPartnerConnection>>,
    TError,
    { data: UserManagementAPIModelsRequestsCreatePartnerConnectionRequest },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPartnerConnection>>,
  TError,
  { data: UserManagementAPIModelsRequestsCreatePartnerConnectionRequest },
  TContext
> => {
  const mutationKey = ["createPartnerConnection"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPartnerConnection>>,
    { data: UserManagementAPIModelsRequestsCreatePartnerConnectionRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createPartnerConnection(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePartnerConnectionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPartnerConnection>>
>;
export type CreatePartnerConnectionMutationBody =
  UserManagementAPIModelsRequestsCreatePartnerConnectionRequest;
export type CreatePartnerConnectionMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Creates a new partner connection request
 */
export const useCreatePartnerConnection = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createPartnerConnection>>,
      TError,
      { data: UserManagementAPIModelsRequestsCreatePartnerConnectionRequest },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createPartnerConnection>>,
  TError,
  { data: UserManagementAPIModelsRequestsCreatePartnerConnectionRequest },
  TContext
> => {
  const mutationOptions = getCreatePartnerConnectionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Gets a partner connection by ID
 */
export const getGetPartnerConnectionByIdUrl = ({
  connectionId,
}: GetPartnerConnectionByIdPathParameters) => {
  return `/user-management/api/v1/partner-connections/${connectionId}`;
};

export const getPartnerConnectionById = async (
  { connectionId }: GetPartnerConnectionByIdPathParameters,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsPartnerConnectionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsPartnerConnectionDto>(
    getGetPartnerConnectionByIdUrl({ connectionId }),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetPartnerConnectionByIdQueryKey = ({
  connectionId,
}: GetPartnerConnectionByIdPathParameters) => {
  return [
    "user-management",
    "api",
    "v1",
    "partner-connections",
    connectionId,
  ] as const;
};

export const useGetPartnerConnectionByIdInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPartnerConnectionById>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { connectionId }: GetPartnerConnectionByIdPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPartnerConnectionByIdQueryKey({ connectionId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPartnerConnectionById>>
  > = ({ signal }) =>
    getPartnerConnectionById({ connectionId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPartnerConnectionById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPartnerConnectionByIdInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPartnerConnectionById>>
>;
export type GetPartnerConnectionByIdInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetPartnerConnectionByIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPartnerConnectionById>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionByIdPathParameters,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnerConnectionById>>,
          TError,
          Awaited<ReturnType<typeof getPartnerConnectionById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPartnerConnectionByIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPartnerConnectionById>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionByIdPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnerConnectionById>>,
          TError,
          Awaited<ReturnType<typeof getPartnerConnectionById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPartnerConnectionByIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPartnerConnectionById>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionByIdPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets a partner connection by ID
 */

export function useGetPartnerConnectionByIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPartnerConnectionById>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { connectionId }: GetPartnerConnectionByIdPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetPartnerConnectionByIdInfiniteQueryOptions(
    { connectionId },
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a partner connection by ID
 */
export const prefetchGetPartnerConnectionByIdInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getPartnerConnectionById>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { connectionId }: GetPartnerConnectionByIdPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetPartnerConnectionByIdInfiniteQueryOptions(
    { connectionId },
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetPartnerConnectionByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getPartnerConnectionById>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { connectionId }: GetPartnerConnectionByIdPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPartnerConnectionByIdQueryKey({ connectionId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPartnerConnectionById>>
  > = ({ signal }) =>
    getPartnerConnectionById({ connectionId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getPartnerConnectionById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPartnerConnectionByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPartnerConnectionById>>
>;
export type GetPartnerConnectionByIdQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetPartnerConnectionById<
  TData = Awaited<ReturnType<typeof getPartnerConnectionById>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionByIdPathParameters,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnerConnectionById>>,
          TError,
          Awaited<ReturnType<typeof getPartnerConnectionById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPartnerConnectionById<
  TData = Awaited<ReturnType<typeof getPartnerConnectionById>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionByIdPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnerConnectionById>>,
          TError,
          Awaited<ReturnType<typeof getPartnerConnectionById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPartnerConnectionById<
  TData = Awaited<ReturnType<typeof getPartnerConnectionById>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionByIdPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets a partner connection by ID
 */

export function useGetPartnerConnectionById<
  TData = Awaited<ReturnType<typeof getPartnerConnectionById>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { connectionId }: GetPartnerConnectionByIdPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetPartnerConnectionByIdQueryOptions(
    { connectionId },
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets a partner connection by ID
 */
export const prefetchGetPartnerConnectionByIdQuery = async <
  TData = Awaited<ReturnType<typeof getPartnerConnectionById>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { connectionId }: GetPartnerConnectionByIdPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetPartnerConnectionByIdQueryOptions(
    { connectionId },
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Updates an existing partner connection
 */
export const getUpdatePartnerConnectionUrl = ({
  connectionId,
}: UpdatePartnerConnectionPathParameters) => {
  return `/user-management/api/v1/partner-connections/${connectionId}`;
};

export const updatePartnerConnection = async (
  { connectionId }: UpdatePartnerConnectionPathParameters,
  userManagementAPIModelsRequestsUpdatePartnerConnectionRequest: UserManagementAPIModelsRequestsUpdatePartnerConnectionRequest,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsPartnerConnectionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsPartnerConnectionDto>(
    getUpdatePartnerConnectionUrl({ connectionId }),
    {
      ...options,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        userManagementAPIModelsRequestsUpdatePartnerConnectionRequest,
      ),
    },
  );
};

export const getUpdatePartnerConnectionMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePartnerConnection>>,
    TError,
    {
      pathParams: UpdatePartnerConnectionPathParameters;
      data: UserManagementAPIModelsRequestsUpdatePartnerConnectionRequest;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePartnerConnection>>,
  TError,
  {
    pathParams: UpdatePartnerConnectionPathParameters;
    data: UserManagementAPIModelsRequestsUpdatePartnerConnectionRequest;
  },
  TContext
> => {
  const mutationKey = ["updatePartnerConnection"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePartnerConnection>>,
    {
      pathParams: UpdatePartnerConnectionPathParameters;
      data: UserManagementAPIModelsRequestsUpdatePartnerConnectionRequest;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return updatePartnerConnection(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePartnerConnectionMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePartnerConnection>>
>;
export type UpdatePartnerConnectionMutationBody =
  UserManagementAPIModelsRequestsUpdatePartnerConnectionRequest;
export type UpdatePartnerConnectionMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Updates an existing partner connection
 */
export const useUpdatePartnerConnection = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePartnerConnection>>,
      TError,
      {
        pathParams: UpdatePartnerConnectionPathParameters;
        data: UserManagementAPIModelsRequestsUpdatePartnerConnectionRequest;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updatePartnerConnection>>,
  TError,
  {
    pathParams: UpdatePartnerConnectionPathParameters;
    data: UserManagementAPIModelsRequestsUpdatePartnerConnectionRequest;
  },
  TContext
> => {
  const mutationOptions = getUpdatePartnerConnectionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Approves a partner connection request
 */
export const getApprovePartnerConnectionUrl = ({
  connectionId,
}: ApprovePartnerConnectionPathParameters) => {
  return `/user-management/api/v1/partner-connections/${connectionId}/approve`;
};

export const approvePartnerConnection = async (
  { connectionId }: ApprovePartnerConnectionPathParameters,
  userManagementAPIModelsRequestsApprovePartnerConnectionRequest: UserManagementAPIModelsRequestsApprovePartnerConnectionRequest,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsPartnerConnectionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsPartnerConnectionDto>(
    getApprovePartnerConnectionUrl({ connectionId }),
    {
      ...options,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        userManagementAPIModelsRequestsApprovePartnerConnectionRequest,
      ),
    },
  );
};

export const getApprovePartnerConnectionMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof approvePartnerConnection>>,
    TError,
    {
      pathParams: ApprovePartnerConnectionPathParameters;
      data: UserManagementAPIModelsRequestsApprovePartnerConnectionRequest;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof approvePartnerConnection>>,
  TError,
  {
    pathParams: ApprovePartnerConnectionPathParameters;
    data: UserManagementAPIModelsRequestsApprovePartnerConnectionRequest;
  },
  TContext
> => {
  const mutationKey = ["approvePartnerConnection"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof approvePartnerConnection>>,
    {
      pathParams: ApprovePartnerConnectionPathParameters;
      data: UserManagementAPIModelsRequestsApprovePartnerConnectionRequest;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return approvePartnerConnection(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ApprovePartnerConnectionMutationResult = NonNullable<
  Awaited<ReturnType<typeof approvePartnerConnection>>
>;
export type ApprovePartnerConnectionMutationBody =
  UserManagementAPIModelsRequestsApprovePartnerConnectionRequest;
export type ApprovePartnerConnectionMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Approves a partner connection request
 */
export const useApprovePartnerConnection = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof approvePartnerConnection>>,
      TError,
      {
        pathParams: ApprovePartnerConnectionPathParameters;
        data: UserManagementAPIModelsRequestsApprovePartnerConnectionRequest;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof approvePartnerConnection>>,
  TError,
  {
    pathParams: ApprovePartnerConnectionPathParameters;
    data: UserManagementAPIModelsRequestsApprovePartnerConnectionRequest;
  },
  TContext
> => {
  const mutationOptions = getApprovePartnerConnectionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Rejects a partner connection request
 */
export const getRejectPartnerConnectionUrl = ({
  connectionId,
}: RejectPartnerConnectionPathParameters) => {
  return `/user-management/api/v1/partner-connections/${connectionId}/reject`;
};

export const rejectPartnerConnection = async (
  { connectionId }: RejectPartnerConnectionPathParameters,
  userManagementAPIModelsRequestsRejectPartnerConnectionRequest: UserManagementAPIModelsRequestsRejectPartnerConnectionRequest,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsPartnerConnectionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsPartnerConnectionDto>(
    getRejectPartnerConnectionUrl({ connectionId }),
    {
      ...options,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        userManagementAPIModelsRequestsRejectPartnerConnectionRequest,
      ),
    },
  );
};

export const getRejectPartnerConnectionMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rejectPartnerConnection>>,
    TError,
    {
      pathParams: RejectPartnerConnectionPathParameters;
      data: UserManagementAPIModelsRequestsRejectPartnerConnectionRequest;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rejectPartnerConnection>>,
  TError,
  {
    pathParams: RejectPartnerConnectionPathParameters;
    data: UserManagementAPIModelsRequestsRejectPartnerConnectionRequest;
  },
  TContext
> => {
  const mutationKey = ["rejectPartnerConnection"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rejectPartnerConnection>>,
    {
      pathParams: RejectPartnerConnectionPathParameters;
      data: UserManagementAPIModelsRequestsRejectPartnerConnectionRequest;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return rejectPartnerConnection(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RejectPartnerConnectionMutationResult = NonNullable<
  Awaited<ReturnType<typeof rejectPartnerConnection>>
>;
export type RejectPartnerConnectionMutationBody =
  UserManagementAPIModelsRequestsRejectPartnerConnectionRequest;
export type RejectPartnerConnectionMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Rejects a partner connection request
 */
export const useRejectPartnerConnection = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rejectPartnerConnection>>,
      TError,
      {
        pathParams: RejectPartnerConnectionPathParameters;
        data: UserManagementAPIModelsRequestsRejectPartnerConnectionRequest;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof rejectPartnerConnection>>,
  TError,
  {
    pathParams: RejectPartnerConnectionPathParameters;
    data: UserManagementAPIModelsRequestsRejectPartnerConnectionRequest;
  },
  TContext
> => {
  const mutationOptions = getRejectPartnerConnectionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Terminates an approved partner connection
 */
export const getTerminatePartnerConnectionUrl = ({
  connectionId,
}: TerminatePartnerConnectionPathParameters) => {
  return `/user-management/api/v1/partner-connections/${connectionId}/terminate`;
};

export const terminatePartnerConnection = async (
  { connectionId }: TerminatePartnerConnectionPathParameters,
  userManagementAPIModelsRequestsTerminatePartnerConnectionRequest: UserManagementAPIModelsRequestsTerminatePartnerConnectionRequest,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsPartnerConnectionDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsPartnerConnectionDto>(
    getTerminatePartnerConnectionUrl({ connectionId }),
    {
      ...options,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        userManagementAPIModelsRequestsTerminatePartnerConnectionRequest,
      ),
    },
  );
};

export const getTerminatePartnerConnectionMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof terminatePartnerConnection>>,
    TError,
    {
      pathParams: TerminatePartnerConnectionPathParameters;
      data: UserManagementAPIModelsRequestsTerminatePartnerConnectionRequest;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof terminatePartnerConnection>>,
  TError,
  {
    pathParams: TerminatePartnerConnectionPathParameters;
    data: UserManagementAPIModelsRequestsTerminatePartnerConnectionRequest;
  },
  TContext
> => {
  const mutationKey = ["terminatePartnerConnection"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof terminatePartnerConnection>>,
    {
      pathParams: TerminatePartnerConnectionPathParameters;
      data: UserManagementAPIModelsRequestsTerminatePartnerConnectionRequest;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return terminatePartnerConnection(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TerminatePartnerConnectionMutationResult = NonNullable<
  Awaited<ReturnType<typeof terminatePartnerConnection>>
>;
export type TerminatePartnerConnectionMutationBody =
  UserManagementAPIModelsRequestsTerminatePartnerConnectionRequest;
export type TerminatePartnerConnectionMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary Terminates an approved partner connection
 */
export const useTerminatePartnerConnection = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof terminatePartnerConnection>>,
      TError,
      {
        pathParams: TerminatePartnerConnectionPathParameters;
        data: UserManagementAPIModelsRequestsTerminatePartnerConnectionRequest;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof terminatePartnerConnection>>,
  TError,
  {
    pathParams: TerminatePartnerConnectionPathParameters;
    data: UserManagementAPIModelsRequestsTerminatePartnerConnectionRequest;
  },
  TContext
> => {
  const mutationOptions = getTerminatePartnerConnectionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Gets partner connections for the current user's teams
 */
export const getGetMyTeamsPartnerConnectionsUrl = (
  params?: GetMyTeamsPartnerConnectionsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/user-management/api/v1/partner-connections/my-teams?${stringifiedParams}`
    : `/user-management/api/v1/partner-connections/my-teams`;
};

export const getMyTeamsPartnerConnections = async (
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: RequestInit,
): Promise<ClicksiDataContractsCommonModelsResponsesPagedResponse1UserManagementDomainDTOsPartnerConnectionDto> => {
  return gatewayServiceCustomFetch<ClicksiDataContractsCommonModelsResponsesPagedResponse1UserManagementDomainDTOsPartnerConnectionDto>(
    getGetMyTeamsPartnerConnectionsUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetMyTeamsPartnerConnectionsQueryKey = (
  params?: GetMyTeamsPartnerConnectionsParams,
) => {
  return [
    "user-management",
    "api",
    "v1",
    "partner-connections",
    "my-teams",
    ...(params ? [params] : []),
  ] as const;
};

export const useGetMyTeamsPartnerConnectionsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMyTeamsPartnerConnectionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
  > = ({ signal }) =>
    getMyTeamsPartnerConnections(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyTeamsPartnerConnectionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
>;
export type GetMyTeamsPartnerConnectionsInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetMyTeamsPartnerConnectionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetMyTeamsPartnerConnectionsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
          TError,
          Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyTeamsPartnerConnectionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
          TError,
          Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyTeamsPartnerConnectionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets partner connections for the current user's teams
 */

export function useGetMyTeamsPartnerConnectionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetMyTeamsPartnerConnectionsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets partner connections for the current user's teams
 */
export const prefetchGetMyTeamsPartnerConnectionsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetMyTeamsPartnerConnectionsInfiniteQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetMyTeamsPartnerConnectionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMyTeamsPartnerConnectionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
  > = ({ signal }) =>
    getMyTeamsPartnerConnections(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyTeamsPartnerConnectionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
>;
export type GetMyTeamsPartnerConnectionsQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetMyTeamsPartnerConnections<
  TData = Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetMyTeamsPartnerConnectionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
          TError,
          Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyTeamsPartnerConnections<
  TData = Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
          TError,
          Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyTeamsPartnerConnections<
  TData = Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets partner connections for the current user's teams
 */

export function useGetMyTeamsPartnerConnections<
  TData = Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetMyTeamsPartnerConnectionsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets partner connections for the current user's teams
 */
export const prefetchGetMyTeamsPartnerConnectionsQuery = async <
  TData = Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetMyTeamsPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetMyTeamsPartnerConnectionsQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Gets pending partner connection requests for current user's teams
 */
export const getGetMyTeamsPendingConnectionsUrl = () => {
  return `/user-management/api/v1/partner-connections/my-teams/pending`;
};

export const getMyTeamsPendingConnections = async (
  options?: RequestInit,
): Promise<UserManagementDomainDTOsPartnerConnectionDto[]> => {
  return gatewayServiceCustomFetch<
    UserManagementDomainDTOsPartnerConnectionDto[]
  >(getGetMyTeamsPendingConnectionsUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetMyTeamsPendingConnectionsQueryKey = () => {
  return [
    "user-management",
    "api",
    "v1",
    "partner-connections",
    "my-teams",
    "pending",
  ] as const;
};

export const useGetMyTeamsPendingConnectionsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMyTeamsPendingConnectionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
  > = ({ signal }) =>
    getMyTeamsPendingConnections({ signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyTeamsPendingConnectionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
>;
export type GetMyTeamsPendingConnectionsInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetMyTeamsPendingConnectionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
          TError,
          Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyTeamsPendingConnectionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
          TError,
          Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyTeamsPendingConnectionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets pending partner connection requests for current user's teams
 */

export function useGetMyTeamsPendingConnectionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    useGetMyTeamsPendingConnectionsInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets pending partner connection requests for current user's teams
 */
export const prefetchGetMyTeamsPendingConnectionsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions =
    useGetMyTeamsPendingConnectionsInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetMyTeamsPendingConnectionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMyTeamsPendingConnectionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
  > = ({ signal }) =>
    getMyTeamsPendingConnections({ signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyTeamsPendingConnectionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
>;
export type GetMyTeamsPendingConnectionsQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetMyTeamsPendingConnections<
  TData = Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
          TError,
          Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyTeamsPendingConnections<
  TData = Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
          TError,
          Awaited<ReturnType<typeof getMyTeamsPendingConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyTeamsPendingConnections<
  TData = Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets pending partner connection requests for current user's teams
 */

export function useGetMyTeamsPendingConnections<
  TData = Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetMyTeamsPendingConnectionsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets pending partner connection requests for current user's teams
 */
export const prefetchGetMyTeamsPendingConnectionsQuery = async <
  TData = Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyTeamsPendingConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetMyTeamsPendingConnectionsQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Searches for partner connections based on criteria
 */
export const getSearchPartnerConnectionsUrl = (
  params?: SearchPartnerConnectionsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/user-management/api/v1/partner-connections/search?${stringifiedParams}`
    : `/user-management/api/v1/partner-connections/search`;
};

export const searchPartnerConnections = async (
  params?: SearchPartnerConnectionsParams,
  options?: RequestInit,
): Promise<ClicksiDataContractsCommonModelsResponsesPagedResponse1UserManagementDomainDTOsPartnerConnectionDto> => {
  return gatewayServiceCustomFetch<ClicksiDataContractsCommonModelsResponsesPagedResponse1UserManagementDomainDTOsPartnerConnectionDto>(
    getSearchPartnerConnectionsUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getSearchPartnerConnectionsQueryKey = (
  params?: SearchPartnerConnectionsParams,
) => {
  return [
    "user-management",
    "api",
    "v1",
    "partner-connections",
    "search",
    ...(params ? [params] : []),
  ] as const;
};

export const useSearchPartnerConnectionsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof searchPartnerConnections>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: SearchPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSearchPartnerConnectionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchPartnerConnections>>
  > = ({ signal }) =>
    searchPartnerConnections(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchPartnerConnections>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchPartnerConnectionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchPartnerConnections>>
>;
export type SearchPartnerConnectionsInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useSearchPartnerConnectionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchPartnerConnections>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | SearchPartnerConnectionsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchPartnerConnections>>,
          TError,
          Awaited<ReturnType<typeof searchPartnerConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchPartnerConnectionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchPartnerConnections>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: SearchPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchPartnerConnections>>,
          TError,
          Awaited<ReturnType<typeof searchPartnerConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchPartnerConnectionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchPartnerConnections>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: SearchPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Searches for partner connections based on criteria
 */

export function useSearchPartnerConnectionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof searchPartnerConnections>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: SearchPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useSearchPartnerConnectionsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Searches for partner connections based on criteria
 */
export const prefetchSearchPartnerConnectionsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof searchPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: SearchPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useSearchPartnerConnectionsInfiniteQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useSearchPartnerConnectionsQueryOptions = <
  TData = Awaited<ReturnType<typeof searchPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: SearchPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSearchPartnerConnectionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchPartnerConnections>>
  > = ({ signal }) =>
    searchPartnerConnections(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof searchPartnerConnections>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchPartnerConnectionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchPartnerConnections>>
>;
export type SearchPartnerConnectionsQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useSearchPartnerConnections<
  TData = Awaited<ReturnType<typeof searchPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | SearchPartnerConnectionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchPartnerConnections>>,
          TError,
          Awaited<ReturnType<typeof searchPartnerConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchPartnerConnections<
  TData = Awaited<ReturnType<typeof searchPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: SearchPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchPartnerConnections>>,
          TError,
          Awaited<ReturnType<typeof searchPartnerConnections>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchPartnerConnections<
  TData = Awaited<ReturnType<typeof searchPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: SearchPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Searches for partner connections based on criteria
 */

export function useSearchPartnerConnections<
  TData = Awaited<ReturnType<typeof searchPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: SearchPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useSearchPartnerConnectionsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Searches for partner connections based on criteria
 */
export const prefetchSearchPartnerConnectionsQuery = async <
  TData = Awaited<ReturnType<typeof searchPartnerConnections>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: SearchPartnerConnectionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchPartnerConnections>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useSearchPartnerConnectionsQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Gets partner connections for a specific team
 */
export const getGetPartnerConnectionsByTeamUrl = (
  { teamId }: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/user-management/api/v1/partner-connections/team/${teamId}?${stringifiedParams}`
    : `/user-management/api/v1/partner-connections/team/${teamId}`;
};

export const getPartnerConnectionsByTeam = async (
  { teamId }: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: RequestInit,
): Promise<ClicksiDataContractsCommonModelsResponsesPagedResponse1UserManagementDomainDTOsPartnerConnectionDto> => {
  return gatewayServiceCustomFetch<ClicksiDataContractsCommonModelsResponsesPagedResponse1UserManagementDomainDTOsPartnerConnectionDto>(
    getGetPartnerConnectionsByTeamUrl({ teamId }, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetPartnerConnectionsByTeamQueryKey = (
  { teamId }: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
) => {
  return [
    "user-management",
    "api",
    "v1",
    "partner-connections",
    "team",
    teamId,
    ...(params ? [params] : []),
  ] as const;
};

export const useGetPartnerConnectionsByTeamInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPartnerConnectionsByTeamQueryKey({ teamId }, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>
  > = ({ signal }) =>
    getPartnerConnectionsByTeam({ teamId }, params, {
      signal,
      ...requestOptions,
    });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPartnerConnectionsByTeamInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>
>;
export type GetPartnerConnectionsByTeamInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetPartnerConnectionsByTeamInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionsByTeamPathParameters,
  params: undefined | GetPartnerConnectionsByTeamParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
          TError,
          Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPartnerConnectionsByTeamInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
          TError,
          Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPartnerConnectionsByTeamInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets partner connections for a specific team
 */

export function useGetPartnerConnectionsByTeamInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetPartnerConnectionsByTeamInfiniteQueryOptions(
    { teamId },
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets partner connections for a specific team
 */
export const prefetchGetPartnerConnectionsByTeamInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { teamId }: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetPartnerConnectionsByTeamInfiniteQueryOptions(
    { teamId },
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetPartnerConnectionsByTeamQueryOptions = <
  TData = Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPartnerConnectionsByTeamQueryKey({ teamId }, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>
  > = ({ signal }) =>
    getPartnerConnectionsByTeam({ teamId }, params, {
      signal,
      ...requestOptions,
    });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPartnerConnectionsByTeamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>
>;
export type GetPartnerConnectionsByTeamQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetPartnerConnectionsByTeam<
  TData = Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionsByTeamPathParameters,
  params: undefined | GetPartnerConnectionsByTeamParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
          TError,
          Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPartnerConnectionsByTeam<
  TData = Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
          TError,
          Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPartnerConnectionsByTeam<
  TData = Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets partner connections for a specific team
 */

export function useGetPartnerConnectionsByTeam<
  TData = Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetPartnerConnectionsByTeamQueryOptions(
    { teamId },
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets partner connections for a specific team
 */
export const prefetchGetPartnerConnectionsByTeamQuery = async <
  TData = Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { teamId }: GetPartnerConnectionsByTeamPathParameters,
  params?: GetPartnerConnectionsByTeamParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPartnerConnectionsByTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetPartnerConnectionsByTeamQueryOptions(
    { teamId },
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary Gets pending partner connection requests for a team
 */
export const getGetPendingPartnerConnectionsForTeamUrl = ({
  teamId,
}: GetPendingPartnerConnectionsForTeamPathParameters) => {
  return `/user-management/api/v1/partner-connections/team/${teamId}/pending`;
};

export const getPendingPartnerConnectionsForTeam = async (
  { teamId }: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsPartnerConnectionDto[]> => {
  return gatewayServiceCustomFetch<
    UserManagementDomainDTOsPartnerConnectionDto[]
  >(getGetPendingPartnerConnectionsForTeamUrl({ teamId }), {
    ...options,
    method: "GET",
  });
};

export const getGetPendingPartnerConnectionsForTeamQueryKey = ({
  teamId,
}: GetPendingPartnerConnectionsForTeamPathParameters) => {
  return [
    "user-management",
    "api",
    "v1",
    "partner-connections",
    "team",
    teamId,
    "pending",
  ] as const;
};

export const useGetPendingPartnerConnectionsForTeamInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPendingPartnerConnectionsForTeamQueryKey({ teamId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
  > = ({ signal }) =>
    getPendingPartnerConnectionsForTeam(
      { teamId },
      { signal, ...requestOptions },
    );

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingPartnerConnectionsForTeamInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>>;
export type GetPendingPartnerConnectionsForTeamInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetPendingPartnerConnectionsForTeamInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPendingPartnerConnectionsForTeamPathParameters,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
          TError,
          Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingPartnerConnectionsForTeamInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
          TError,
          Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingPartnerConnectionsForTeamInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets pending partner connection requests for a team
 */

export function useGetPendingPartnerConnectionsForTeamInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    useGetPendingPartnerConnectionsForTeamInfiniteQueryOptions(
      { teamId },
      options,
    );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets pending partner connection requests for a team
 */
export const prefetchGetPendingPartnerConnectionsForTeamInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { teamId }: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions =
    useGetPendingPartnerConnectionsForTeamInfiniteQueryOptions(
      { teamId },
      options,
    );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetPendingPartnerConnectionsForTeamQueryOptions = <
  TData = Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPendingPartnerConnectionsForTeamQueryKey({ teamId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
  > = ({ signal }) =>
    getPendingPartnerConnectionsForTeam(
      { teamId },
      { signal, ...requestOptions },
    );

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingPartnerConnectionsForTeamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
>;
export type GetPendingPartnerConnectionsForTeamQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetPendingPartnerConnectionsForTeam<
  TData = Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPendingPartnerConnectionsForTeamPathParameters,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
          TError,
          Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingPartnerConnectionsForTeam<
  TData = Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
          TError,
          Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingPartnerConnectionsForTeam<
  TData = Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets pending partner connection requests for a team
 */

export function useGetPendingPartnerConnectionsForTeam<
  TData = Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { teamId }: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetPendingPartnerConnectionsForTeamQueryOptions(
    { teamId },
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Gets pending partner connection requests for a team
 */
export const prefetchGetPendingPartnerConnectionsForTeamQuery = async <
  TData = Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { teamId }: GetPendingPartnerConnectionsForTeamPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingPartnerConnectionsForTeam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetPendingPartnerConnectionsForTeamQueryOptions(
    { teamId },
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};
