/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * UserManagement.API
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AddVerificationDocumentBody,
  AddVerificationDocumentPathParameters,
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  CreateVerificationApplicationBody,
  DeleteVerificationDocumentPathParameters,
  DownloadVerificationDocumentPathParameters,
  GetPendingVerificationCountParams,
  GetVerificationApplicationPathParameters,
  GetVerificationApplicationsParams,
  GetVerificationDocumentPathParameters,
  SubmitVerificationApplicationPathParameters,
  UpdateVerificationApplicationPathParameters,
  UpdateVerificationStatusPathParameters,
  UserManagementAPIControllersPendingVerificationCountResponse,
  UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto,
  UserManagementAPIControllersUpdateVerificationStatusRequest,
  UserManagementAPIServicesVerificationDocumentCleanupItem,
  UserManagementAPIServicesVerificationDocumentCleanupResult,
  UserManagementDomainDTOsVerificationApplicationDto,
  UserManagementDomainDTOsVerificationDocumentDto,
  UserManagementDomainDTOsVerificationListDto,
} from "../../types";

import { gatewayServiceCustomFetch } from "../../../../lib/orval/orval-fetch";
import { customQueryOptions } from "../../../../lib/orval/custom-query-options";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary [Verification] Create Verification Application
 */
export const getCreateVerificationApplicationUrl = () => {
  return `/user-management/api/v1/verifications`;
};

export const createVerificationApplication = async (
  createVerificationApplicationBody: CreateVerificationApplicationBody,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsVerificationApplicationDto> => {
  const formData = new FormData();
  if (createVerificationApplicationBody.json !== undefined) {
    formData.append(
      `json`,
      JSON.stringify(createVerificationApplicationBody.json),
    );
  }
  createVerificationApplicationBody.documents.forEach((value) =>
    formData.append(`documents`, value),
  );

  return gatewayServiceCustomFetch<UserManagementDomainDTOsVerificationApplicationDto>(
    getCreateVerificationApplicationUrl(),
    {
      ...options,
      method: "POST",
      body: formData,
    },
  );
};

export const getCreateVerificationApplicationMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVerificationApplication>>,
    TError,
    { data: CreateVerificationApplicationBody },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createVerificationApplication>>,
  TError,
  { data: CreateVerificationApplicationBody },
  TContext
> => {
  const mutationKey = ["createVerificationApplication"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createVerificationApplication>>,
    { data: CreateVerificationApplicationBody }
  > = (props) => {
    const { data } = props ?? {};

    return createVerificationApplication(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateVerificationApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createVerificationApplication>>
>;
export type CreateVerificationApplicationMutationBody =
  CreateVerificationApplicationBody;
export type CreateVerificationApplicationMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary [Verification] Create Verification Application
 */
export const useCreateVerificationApplication = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createVerificationApplication>>,
      TError,
      { data: CreateVerificationApplicationBody },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createVerificationApplication>>,
  TError,
  { data: CreateVerificationApplicationBody },
  TContext
> => {
  const mutationOptions =
    getCreateVerificationApplicationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary [Verification] Get Verification Applications
 */
export const getGetVerificationApplicationsUrl = (
  params?: GetVerificationApplicationsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/user-management/api/v1/verifications?${stringifiedParams}`
    : `/user-management/api/v1/verifications`;
};

export const getVerificationApplications = async (
  params?: GetVerificationApplicationsParams,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsVerificationListDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsVerificationListDto>(
    getGetVerificationApplicationsUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetVerificationApplicationsQueryKey = (
  params?: GetVerificationApplicationsParams,
) => {
  return [
    "user-management",
    "api",
    "v1",
    "verifications",
    ...(params ? [params] : []),
  ] as const;
};

export const useGetVerificationApplicationsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationApplications>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetVerificationApplicationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVerificationApplicationsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVerificationApplications>>
  > = ({ signal }) =>
    getVerificationApplications(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getVerificationApplications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVerificationApplicationsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVerificationApplications>>
>;
export type GetVerificationApplicationsInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetVerificationApplicationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationApplications>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetVerificationApplicationsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationApplications>>,
          TError,
          Awaited<ReturnType<typeof getVerificationApplications>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationApplicationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationApplications>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetVerificationApplicationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationApplications>>,
          TError,
          Awaited<ReturnType<typeof getVerificationApplications>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationApplicationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationApplications>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetVerificationApplicationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get Verification Applications
 */

export function useGetVerificationApplicationsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationApplications>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetVerificationApplicationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetVerificationApplicationsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get Verification Applications
 */
export const prefetchGetVerificationApplicationsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getVerificationApplications>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetVerificationApplicationsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetVerificationApplicationsInfiniteQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetVerificationApplicationsQueryOptions = <
  TData = Awaited<ReturnType<typeof getVerificationApplications>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetVerificationApplicationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVerificationApplicationsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVerificationApplications>>
  > = ({ signal }) =>
    getVerificationApplications(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getVerificationApplications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVerificationApplicationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVerificationApplications>>
>;
export type GetVerificationApplicationsQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetVerificationApplications<
  TData = Awaited<ReturnType<typeof getVerificationApplications>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetVerificationApplicationsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationApplications>>,
          TError,
          Awaited<ReturnType<typeof getVerificationApplications>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationApplications<
  TData = Awaited<ReturnType<typeof getVerificationApplications>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetVerificationApplicationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationApplications>>,
          TError,
          Awaited<ReturnType<typeof getVerificationApplications>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationApplications<
  TData = Awaited<ReturnType<typeof getVerificationApplications>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetVerificationApplicationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get Verification Applications
 */

export function useGetVerificationApplications<
  TData = Awaited<ReturnType<typeof getVerificationApplications>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetVerificationApplicationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetVerificationApplicationsQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get Verification Applications
 */
export const prefetchGetVerificationApplicationsQuery = async <
  TData = Awaited<ReturnType<typeof getVerificationApplications>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetVerificationApplicationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetVerificationApplicationsQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary [Verification] Get Verification Application
 */
export const getGetVerificationApplicationUrl = ({
  id,
}: GetVerificationApplicationPathParameters) => {
  return `/user-management/api/v1/verifications/${id}`;
};

export const getVerificationApplication = async (
  { id }: GetVerificationApplicationPathParameters,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsVerificationApplicationDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsVerificationApplicationDto>(
    getGetVerificationApplicationUrl({ id }),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetVerificationApplicationQueryKey = ({
  id,
}: GetVerificationApplicationPathParameters) => {
  return ["user-management", "api", "v1", "verifications", id] as const;
};

export const useGetVerificationApplicationInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationApplication>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { id }: GetVerificationApplicationPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVerificationApplicationQueryKey({ id });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVerificationApplication>>
  > = ({ signal }) =>
    getVerificationApplication({ id }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getVerificationApplication>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVerificationApplicationInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVerificationApplication>>
>;
export type GetVerificationApplicationInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetVerificationApplicationInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationApplication>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationApplicationPathParameters,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationApplication>>,
          TError,
          Awaited<ReturnType<typeof getVerificationApplication>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationApplicationInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationApplication>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationApplicationPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationApplication>>,
          TError,
          Awaited<ReturnType<typeof getVerificationApplication>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationApplicationInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationApplication>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationApplicationPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get Verification Application
 */

export function useGetVerificationApplicationInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationApplication>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { id }: GetVerificationApplicationPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetVerificationApplicationInfiniteQueryOptions(
    { id },
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get Verification Application
 */
export const prefetchGetVerificationApplicationInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { id }: GetVerificationApplicationPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetVerificationApplicationInfiniteQueryOptions(
    { id },
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetVerificationApplicationQueryOptions = <
  TData = Awaited<ReturnType<typeof getVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { id }: GetVerificationApplicationPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetVerificationApplicationQueryKey({ id });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVerificationApplication>>
  > = ({ signal }) =>
    getVerificationApplication({ id }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getVerificationApplication>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVerificationApplicationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVerificationApplication>>
>;
export type GetVerificationApplicationQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetVerificationApplication<
  TData = Awaited<ReturnType<typeof getVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationApplicationPathParameters,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationApplication>>,
          TError,
          Awaited<ReturnType<typeof getVerificationApplication>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationApplication<
  TData = Awaited<ReturnType<typeof getVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationApplicationPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationApplication>>,
          TError,
          Awaited<ReturnType<typeof getVerificationApplication>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationApplication<
  TData = Awaited<ReturnType<typeof getVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationApplicationPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get Verification Application
 */

export function useGetVerificationApplication<
  TData = Awaited<ReturnType<typeof getVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { id }: GetVerificationApplicationPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetVerificationApplicationQueryOptions(
    { id },
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get Verification Application
 */
export const prefetchGetVerificationApplicationQuery = async <
  TData = Awaited<ReturnType<typeof getVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { id }: GetVerificationApplicationPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetVerificationApplicationQueryOptions(
    { id },
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary [Verification] Update Verification Application
 */
export const getUpdateVerificationApplicationUrl = ({
  id,
}: UpdateVerificationApplicationPathParameters) => {
  return `/user-management/api/v1/verifications/${id}`;
};

export const updateVerificationApplication = async (
  { id }: UpdateVerificationApplicationPathParameters,
  userManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsVerificationApplicationDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsVerificationApplicationDto>(
    getUpdateVerificationApplicationUrl({ id }),
    {
      ...options,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        userManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto,
      ),
    },
  );
};

export const getUpdateVerificationApplicationMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVerificationApplication>>,
    TError,
    {
      pathParams: UpdateVerificationApplicationPathParameters;
      data: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateVerificationApplication>>,
  TError,
  {
    pathParams: UpdateVerificationApplicationPathParameters;
    data: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
  },
  TContext
> => {
  const mutationKey = ["updateVerificationApplication"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateVerificationApplication>>,
    {
      pathParams: UpdateVerificationApplicationPathParameters;
      data: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return updateVerificationApplication(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateVerificationApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateVerificationApplication>>
>;
export type UpdateVerificationApplicationMutationBody =
  UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
export type UpdateVerificationApplicationMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary [Verification] Update Verification Application
 */
export const useUpdateVerificationApplication = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateVerificationApplication>>,
      TError,
      {
        pathParams: UpdateVerificationApplicationPathParameters;
        data: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateVerificationApplication>>,
  TError,
  {
    pathParams: UpdateVerificationApplicationPathParameters;
    data: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
  },
  TContext
> => {
  const mutationOptions =
    getUpdateVerificationApplicationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary [Verification] Add Verification Document
 */
export const getAddVerificationDocumentUrl = ({
  id,
}: AddVerificationDocumentPathParameters) => {
  return `/user-management/api/v1/verifications/${id}/documents`;
};

export const addVerificationDocument = async (
  { id }: AddVerificationDocumentPathParameters,
  addVerificationDocumentBody: AddVerificationDocumentBody,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsVerificationDocumentDto> => {
  const formData = new FormData();
  if (addVerificationDocumentBody.json !== undefined) {
    formData.append(`json`, JSON.stringify(addVerificationDocumentBody.json));
  }
  formData.append(`document`, addVerificationDocumentBody.document);

  return gatewayServiceCustomFetch<UserManagementDomainDTOsVerificationDocumentDto>(
    getAddVerificationDocumentUrl({ id }),
    {
      ...options,
      method: "POST",
      body: formData,
    },
  );
};

export const getAddVerificationDocumentMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addVerificationDocument>>,
    TError,
    {
      pathParams: AddVerificationDocumentPathParameters;
      data: AddVerificationDocumentBody;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addVerificationDocument>>,
  TError,
  {
    pathParams: AddVerificationDocumentPathParameters;
    data: AddVerificationDocumentBody;
  },
  TContext
> => {
  const mutationKey = ["addVerificationDocument"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addVerificationDocument>>,
    {
      pathParams: AddVerificationDocumentPathParameters;
      data: AddVerificationDocumentBody;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return addVerificationDocument(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddVerificationDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof addVerificationDocument>>
>;
export type AddVerificationDocumentMutationBody = AddVerificationDocumentBody;
export type AddVerificationDocumentMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary [Verification] Add Verification Document
 */
export const useAddVerificationDocument = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addVerificationDocument>>,
      TError,
      {
        pathParams: AddVerificationDocumentPathParameters;
        data: AddVerificationDocumentBody;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addVerificationDocument>>,
  TError,
  {
    pathParams: AddVerificationDocumentPathParameters;
    data: AddVerificationDocumentBody;
  },
  TContext
> => {
  const mutationOptions = getAddVerificationDocumentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary [Verification] Delete Verification Document
 */
export const getDeleteVerificationDocumentUrl = ({
  id,
  documentId,
}: DeleteVerificationDocumentPathParameters) => {
  return `/user-management/api/v1/verifications/${id}/documents/${documentId}`;
};

export const deleteVerificationDocument = async (
  { id, documentId }: DeleteVerificationDocumentPathParameters,
  options?: RequestInit,
): Promise<void> => {
  return gatewayServiceCustomFetch<void>(
    getDeleteVerificationDocumentUrl({ id, documentId }),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getDeleteVerificationDocumentMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteVerificationDocument>>,
    TError,
    { pathParams: DeleteVerificationDocumentPathParameters },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteVerificationDocument>>,
  TError,
  { pathParams: DeleteVerificationDocumentPathParameters },
  TContext
> => {
  const mutationKey = ["deleteVerificationDocument"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteVerificationDocument>>,
    { pathParams: DeleteVerificationDocumentPathParameters }
  > = (props) => {
    const { pathParams } = props ?? {};

    return deleteVerificationDocument(pathParams, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteVerificationDocumentMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteVerificationDocument>>
>;

export type DeleteVerificationDocumentMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary [Verification] Delete Verification Document
 */
export const useDeleteVerificationDocument = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteVerificationDocument>>,
      TError,
      { pathParams: DeleteVerificationDocumentPathParameters },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteVerificationDocument>>,
  TError,
  { pathParams: DeleteVerificationDocumentPathParameters },
  TContext
> => {
  const mutationOptions = getDeleteVerificationDocumentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary [Verification] Update Verification Status
 */
export const getUpdateVerificationStatusUrl = ({
  id,
}: UpdateVerificationStatusPathParameters) => {
  return `/user-management/api/v1/verifications/${id}/status`;
};

export const updateVerificationStatus = async (
  { id }: UpdateVerificationStatusPathParameters,
  userManagementAPIControllersUpdateVerificationStatusRequest: UserManagementAPIControllersUpdateVerificationStatusRequest,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsVerificationApplicationDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsVerificationApplicationDto>(
    getUpdateVerificationStatusUrl({ id }),
    {
      ...options,
      method: "PUT",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        userManagementAPIControllersUpdateVerificationStatusRequest,
      ),
    },
  );
};

export const getUpdateVerificationStatusMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateVerificationStatus>>,
    TError,
    {
      pathParams: UpdateVerificationStatusPathParameters;
      data: UserManagementAPIControllersUpdateVerificationStatusRequest;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateVerificationStatus>>,
  TError,
  {
    pathParams: UpdateVerificationStatusPathParameters;
    data: UserManagementAPIControllersUpdateVerificationStatusRequest;
  },
  TContext
> => {
  const mutationKey = ["updateVerificationStatus"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateVerificationStatus>>,
    {
      pathParams: UpdateVerificationStatusPathParameters;
      data: UserManagementAPIControllersUpdateVerificationStatusRequest;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return updateVerificationStatus(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateVerificationStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateVerificationStatus>>
>;
export type UpdateVerificationStatusMutationBody =
  UserManagementAPIControllersUpdateVerificationStatusRequest;
export type UpdateVerificationStatusMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary [Verification] Update Verification Status
 */
export const useUpdateVerificationStatus = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateVerificationStatus>>,
      TError,
      {
        pathParams: UpdateVerificationStatusPathParameters;
        data: UserManagementAPIControllersUpdateVerificationStatusRequest;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateVerificationStatus>>,
  TError,
  {
    pathParams: UpdateVerificationStatusPathParameters;
    data: UserManagementAPIControllersUpdateVerificationStatusRequest;
  },
  TContext
> => {
  const mutationOptions = getUpdateVerificationStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary [Verification] Submit Verification Application
 */
export const getSubmitVerificationApplicationUrl = ({
  id,
}: SubmitVerificationApplicationPathParameters) => {
  return `/user-management/api/v1/verifications/${id}/submit`;
};

export const submitVerificationApplication = async (
  { id }: SubmitVerificationApplicationPathParameters,
  userManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsVerificationApplicationDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsVerificationApplicationDto>(
    getSubmitVerificationApplicationUrl({ id }),
    {
      ...options,
      method: "POST",
      headers: {
        "Content-Type": "application/json-patch+json",
        ...options?.headers,
      },
      body: JSON.stringify(
        userManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto,
      ),
    },
  );
};

export const getSubmitVerificationApplicationMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof submitVerificationApplication>>,
    TError,
    {
      pathParams: SubmitVerificationApplicationPathParameters;
      data: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof submitVerificationApplication>>,
  TError,
  {
    pathParams: SubmitVerificationApplicationPathParameters;
    data: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
  },
  TContext
> => {
  const mutationKey = ["submitVerificationApplication"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof submitVerificationApplication>>,
    {
      pathParams: SubmitVerificationApplicationPathParameters;
      data: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return submitVerificationApplication(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SubmitVerificationApplicationMutationResult = NonNullable<
  Awaited<ReturnType<typeof submitVerificationApplication>>
>;
export type SubmitVerificationApplicationMutationBody =
  UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
export type SubmitVerificationApplicationMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary [Verification] Submit Verification Application
 */
export const useSubmitVerificationApplication = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof submitVerificationApplication>>,
      TError,
      {
        pathParams: SubmitVerificationApplicationPathParameters;
        data: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof submitVerificationApplication>>,
  TError,
  {
    pathParams: SubmitVerificationApplicationPathParameters;
    data: UserManagementAPIControllersUpdateVerificationApplicationUserNotesRequestDto;
  },
  TContext
> => {
  const mutationOptions =
    getSubmitVerificationApplicationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary [Verification] Trigger Document Cleanup
 */
export const getTriggerDocumentCleanupUrl = () => {
  return `/user-management/api/v1/verifications/cleanup`;
};

export const triggerDocumentCleanup = async (
  options?: RequestInit,
): Promise<UserManagementAPIServicesVerificationDocumentCleanupResult> => {
  return gatewayServiceCustomFetch<UserManagementAPIServicesVerificationDocumentCleanupResult>(
    getTriggerDocumentCleanupUrl(),
    {
      ...options,
      method: "POST",
    },
  );
};

export const getTriggerDocumentCleanupMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof triggerDocumentCleanup>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof triggerDocumentCleanup>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["triggerDocumentCleanup"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof triggerDocumentCleanup>>,
    void
  > = () => {
    return triggerDocumentCleanup(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TriggerDocumentCleanupMutationResult = NonNullable<
  Awaited<ReturnType<typeof triggerDocumentCleanup>>
>;

export type TriggerDocumentCleanupMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary [Verification] Trigger Document Cleanup
 */
export const useTriggerDocumentCleanup = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof triggerDocumentCleanup>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof triggerDocumentCleanup>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getTriggerDocumentCleanupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary [Verification] Get Documents Eligible For Cleanup
 */
export const getGetDocumentsEligibleForCleanupUrl = () => {
  return `/user-management/api/v1/verifications/cleanup/eligible`;
};

export const getDocumentsEligibleForCleanup = async (
  options?: RequestInit,
): Promise<UserManagementAPIServicesVerificationDocumentCleanupItem[]> => {
  return gatewayServiceCustomFetch<
    UserManagementAPIServicesVerificationDocumentCleanupItem[]
  >(getGetDocumentsEligibleForCleanupUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetDocumentsEligibleForCleanupQueryKey = () => {
  return [
    "user-management",
    "api",
    "v1",
    "verifications",
    "cleanup",
    "eligible",
  ] as const;
};

export const useGetDocumentsEligibleForCleanupInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDocumentsEligibleForCleanupQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
  > = ({ signal }) =>
    getDocumentsEligibleForCleanup({ signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDocumentsEligibleForCleanupInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
>;
export type GetDocumentsEligibleForCleanupInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetDocumentsEligibleForCleanupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
          TError,
          Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDocumentsEligibleForCleanupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
          TError,
          Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDocumentsEligibleForCleanupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get Documents Eligible For Cleanup
 */

export function useGetDocumentsEligibleForCleanupInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    useGetDocumentsEligibleForCleanupInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get Documents Eligible For Cleanup
 */
export const prefetchGetDocumentsEligibleForCleanupInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions =
    useGetDocumentsEligibleForCleanupInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetDocumentsEligibleForCleanupQueryOptions = <
  TData = Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDocumentsEligibleForCleanupQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
  > = ({ signal }) =>
    getDocumentsEligibleForCleanup({ signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDocumentsEligibleForCleanupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
>;
export type GetDocumentsEligibleForCleanupQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetDocumentsEligibleForCleanup<
  TData = Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
          TError,
          Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDocumentsEligibleForCleanup<
  TData = Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
          TError,
          Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDocumentsEligibleForCleanup<
  TData = Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get Documents Eligible For Cleanup
 */

export function useGetDocumentsEligibleForCleanup<
  TData = Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetDocumentsEligibleForCleanupQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get Documents Eligible For Cleanup
 */
export const prefetchGetDocumentsEligibleForCleanupQuery = async <
  TData = Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDocumentsEligibleForCleanup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetDocumentsEligibleForCleanupQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary [Verification] Get Verification Document
 */
export const getGetVerificationDocumentUrl = ({
  documentId,
}: GetVerificationDocumentPathParameters) => {
  return `/user-management/api/v1/verifications/documents/${documentId}`;
};

export const getVerificationDocument = async (
  { documentId }: GetVerificationDocumentPathParameters,
  options?: RequestInit,
): Promise<UserManagementDomainDTOsVerificationDocumentDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsVerificationDocumentDto>(
    getGetVerificationDocumentUrl({ documentId }),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetVerificationDocumentQueryKey = ({
  documentId,
}: GetVerificationDocumentPathParameters) => {
  return [
    "user-management",
    "api",
    "v1",
    "verifications",
    "documents",
    documentId,
  ] as const;
};

export const useGetVerificationDocumentInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationDocument>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { documentId }: GetVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetVerificationDocumentQueryKey({ documentId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVerificationDocument>>
  > = ({ signal }) =>
    getVerificationDocument({ documentId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getVerificationDocument>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVerificationDocumentInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVerificationDocument>>
>;
export type GetVerificationDocumentInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetVerificationDocumentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationDocument>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationDocumentPathParameters,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationDocument>>,
          TError,
          Awaited<ReturnType<typeof getVerificationDocument>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationDocumentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationDocument>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationDocument>>,
          TError,
          Awaited<ReturnType<typeof getVerificationDocument>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationDocumentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationDocument>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get Verification Document
 */

export function useGetVerificationDocumentInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getVerificationDocument>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { documentId }: GetVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetVerificationDocumentInfiniteQueryOptions(
    { documentId },
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get Verification Document
 */
export const prefetchGetVerificationDocumentInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { documentId }: GetVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetVerificationDocumentInfiniteQueryOptions(
    { documentId },
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetVerificationDocumentQueryOptions = <
  TData = Awaited<ReturnType<typeof getVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { documentId }: GetVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetVerificationDocumentQueryKey({ documentId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVerificationDocument>>
  > = ({ signal }) =>
    getVerificationDocument({ documentId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getVerificationDocument>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVerificationDocumentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVerificationDocument>>
>;
export type GetVerificationDocumentQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetVerificationDocument<
  TData = Awaited<ReturnType<typeof getVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationDocumentPathParameters,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationDocument>>,
          TError,
          Awaited<ReturnType<typeof getVerificationDocument>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationDocument<
  TData = Awaited<ReturnType<typeof getVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerificationDocument>>,
          TError,
          Awaited<ReturnType<typeof getVerificationDocument>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerificationDocument<
  TData = Awaited<ReturnType<typeof getVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get Verification Document
 */

export function useGetVerificationDocument<
  TData = Awaited<ReturnType<typeof getVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { documentId }: GetVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetVerificationDocumentQueryOptions(
    { documentId },
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get Verification Document
 */
export const prefetchGetVerificationDocumentQuery = async <
  TData = Awaited<ReturnType<typeof getVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { documentId }: GetVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetVerificationDocumentQueryOptions(
    { documentId },
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary [Verification] Download Verification Document
 */
export const getDownloadVerificationDocumentUrl = ({
  documentId,
}: DownloadVerificationDocumentPathParameters) => {
  return `/user-management/api/v1/verifications/documents/${documentId}/download`;
};

export const downloadVerificationDocument = async (
  { documentId }: DownloadVerificationDocumentPathParameters,
  options?: RequestInit,
): Promise<Blob> => {
  return gatewayServiceCustomFetch<Blob>(
    getDownloadVerificationDocumentUrl({ documentId }),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getDownloadVerificationDocumentQueryKey = ({
  documentId,
}: DownloadVerificationDocumentPathParameters) => {
  return [
    "user-management",
    "api",
    "v1",
    "verifications",
    "documents",
    documentId,
    "download",
  ] as const;
};

export const useDownloadVerificationDocumentInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof downloadVerificationDocument>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { documentId }: DownloadVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getDownloadVerificationDocumentQueryKey({ documentId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof downloadVerificationDocument>>
  > = ({ signal }) =>
    downloadVerificationDocument({ documentId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof downloadVerificationDocument>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DownloadVerificationDocumentInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof downloadVerificationDocument>>
>;
export type DownloadVerificationDocumentInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useDownloadVerificationDocumentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof downloadVerificationDocument>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: DownloadVerificationDocumentPathParameters,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadVerificationDocument>>,
          TError,
          Awaited<ReturnType<typeof downloadVerificationDocument>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDownloadVerificationDocumentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof downloadVerificationDocument>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: DownloadVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadVerificationDocument>>,
          TError,
          Awaited<ReturnType<typeof downloadVerificationDocument>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDownloadVerificationDocumentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof downloadVerificationDocument>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: DownloadVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Download Verification Document
 */

export function useDownloadVerificationDocumentInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof downloadVerificationDocument>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { documentId }: DownloadVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useDownloadVerificationDocumentInfiniteQueryOptions(
    { documentId },
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Download Verification Document
 */
export const prefetchDownloadVerificationDocumentInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof downloadVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { documentId }: DownloadVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useDownloadVerificationDocumentInfiniteQueryOptions(
    { documentId },
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useDownloadVerificationDocumentQueryOptions = <
  TData = Awaited<ReturnType<typeof downloadVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { documentId }: DownloadVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getDownloadVerificationDocumentQueryKey({ documentId });

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof downloadVerificationDocument>>
  > = ({ signal }) =>
    downloadVerificationDocument({ documentId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof downloadVerificationDocument>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DownloadVerificationDocumentQueryResult = NonNullable<
  Awaited<ReturnType<typeof downloadVerificationDocument>>
>;
export type DownloadVerificationDocumentQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useDownloadVerificationDocument<
  TData = Awaited<ReturnType<typeof downloadVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: DownloadVerificationDocumentPathParameters,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadVerificationDocument>>,
          TError,
          Awaited<ReturnType<typeof downloadVerificationDocument>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDownloadVerificationDocument<
  TData = Awaited<ReturnType<typeof downloadVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: DownloadVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadVerificationDocument>>,
          TError,
          Awaited<ReturnType<typeof downloadVerificationDocument>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDownloadVerificationDocument<
  TData = Awaited<ReturnType<typeof downloadVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: DownloadVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Download Verification Document
 */

export function useDownloadVerificationDocument<
  TData = Awaited<ReturnType<typeof downloadVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { documentId }: DownloadVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useDownloadVerificationDocumentQueryOptions(
    { documentId },
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Download Verification Document
 */
export const prefetchDownloadVerificationDocumentQuery = async <
  TData = Awaited<ReturnType<typeof downloadVerificationDocument>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { documentId }: DownloadVerificationDocumentPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof downloadVerificationDocument>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useDownloadVerificationDocumentQueryOptions(
    { documentId },
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary [Verification] Get My Verification Application
 */
export const getGetMyVerificationApplicationUrl = () => {
  return `/user-management/api/v1/verifications/me`;
};

export const getMyVerificationApplication = async (
  options?: RequestInit,
): Promise<UserManagementDomainDTOsVerificationApplicationDto> => {
  return gatewayServiceCustomFetch<UserManagementDomainDTOsVerificationApplicationDto>(
    getGetMyVerificationApplicationUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetMyVerificationApplicationQueryKey = () => {
  return ["user-management", "api", "v1", "verifications", "me"] as const;
};

export const useGetMyVerificationApplicationInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyVerificationApplication>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getMyVerificationApplication>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMyVerificationApplicationQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMyVerificationApplication>>
  > = ({ signal }) =>
    getMyVerificationApplication({ signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMyVerificationApplication>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyVerificationApplicationInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyVerificationApplication>>
>;
export type GetMyVerificationApplicationInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetMyVerificationApplicationInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyVerificationApplication>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyVerificationApplication>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyVerificationApplication>>,
          TError,
          Awaited<ReturnType<typeof getMyVerificationApplication>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyVerificationApplicationInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyVerificationApplication>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyVerificationApplication>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyVerificationApplication>>,
          TError,
          Awaited<ReturnType<typeof getMyVerificationApplication>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyVerificationApplicationInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyVerificationApplication>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get My Verification Application
 */

export function useGetMyVerificationApplicationInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getMyVerificationApplication>>
  >,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    useGetMyVerificationApplicationInfiniteQueryOptions(options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get My Verification Application
 */
export const prefetchGetMyVerificationApplicationInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getMyVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getMyVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions =
    useGetMyVerificationApplicationInfiniteQueryOptions(options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetMyVerificationApplicationQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getMyVerificationApplication>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMyVerificationApplicationQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMyVerificationApplication>>
  > = ({ signal }) =>
    getMyVerificationApplication({ signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getMyVerificationApplication>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMyVerificationApplicationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyVerificationApplication>>
>;
export type GetMyVerificationApplicationQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetMyVerificationApplication<
  TData = Awaited<ReturnType<typeof getMyVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyVerificationApplication>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyVerificationApplication>>,
          TError,
          Awaited<ReturnType<typeof getMyVerificationApplication>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyVerificationApplication<
  TData = Awaited<ReturnType<typeof getMyVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyVerificationApplication>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyVerificationApplication>>,
          TError,
          Awaited<ReturnType<typeof getMyVerificationApplication>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMyVerificationApplication<
  TData = Awaited<ReturnType<typeof getMyVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get My Verification Application
 */

export function useGetMyVerificationApplication<
  TData = Awaited<ReturnType<typeof getMyVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetMyVerificationApplicationQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get My Verification Application
 */
export const prefetchGetMyVerificationApplicationQuery = async <
  TData = Awaited<ReturnType<typeof getMyVerificationApplication>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMyVerificationApplication>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetMyVerificationApplicationQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary [Verification] Get Pending Verification Count
 */
export const getGetPendingVerificationCountUrl = (
  params?: GetPendingVerificationCountParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/user-management/api/v1/verifications/pending-count?${stringifiedParams}`
    : `/user-management/api/v1/verifications/pending-count`;
};

export const getPendingVerificationCount = async (
  params?: GetPendingVerificationCountParams,
  options?: RequestInit,
): Promise<UserManagementAPIControllersPendingVerificationCountResponse> => {
  return gatewayServiceCustomFetch<UserManagementAPIControllersPendingVerificationCountResponse>(
    getGetPendingVerificationCountUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetPendingVerificationCountQueryKey = (
  params?: GetPendingVerificationCountParams,
) => {
  return [
    "user-management",
    "api",
    "v1",
    "verifications",
    "pending-count",
    ...(params ? [params] : []),
  ] as const;
};

export const useGetPendingVerificationCountInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingVerificationCount>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetPendingVerificationCountParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPendingVerificationCountQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPendingVerificationCount>>
  > = ({ signal }) =>
    getPendingVerificationCount(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getPendingVerificationCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingVerificationCountInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPendingVerificationCount>>
>;
export type GetPendingVerificationCountInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetPendingVerificationCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingVerificationCount>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetPendingVerificationCountParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingVerificationCount>>,
          TError,
          Awaited<ReturnType<typeof getPendingVerificationCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingVerificationCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingVerificationCount>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetPendingVerificationCountParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingVerificationCount>>,
          TError,
          Awaited<ReturnType<typeof getPendingVerificationCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingVerificationCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingVerificationCount>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetPendingVerificationCountParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get Pending Verification Count
 */

export function useGetPendingVerificationCountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPendingVerificationCount>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetPendingVerificationCountParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetPendingVerificationCountInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get Pending Verification Count
 */
export const prefetchGetPendingVerificationCountInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getPendingVerificationCount>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetPendingVerificationCountParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetPendingVerificationCountInfiniteQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetPendingVerificationCountQueryOptions = <
  TData = Awaited<ReturnType<typeof getPendingVerificationCount>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetPendingVerificationCountParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPendingVerificationCountQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPendingVerificationCount>>
  > = ({ signal }) =>
    getPendingVerificationCount(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getPendingVerificationCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPendingVerificationCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPendingVerificationCount>>
>;
export type GetPendingVerificationCountQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetPendingVerificationCount<
  TData = Awaited<ReturnType<typeof getPendingVerificationCount>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetPendingVerificationCountParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingVerificationCount>>,
          TError,
          Awaited<ReturnType<typeof getPendingVerificationCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingVerificationCount<
  TData = Awaited<ReturnType<typeof getPendingVerificationCount>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetPendingVerificationCountParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingVerificationCount>>,
          TError,
          Awaited<ReturnType<typeof getPendingVerificationCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPendingVerificationCount<
  TData = Awaited<ReturnType<typeof getPendingVerificationCount>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetPendingVerificationCountParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Verification] Get Pending Verification Count
 */

export function useGetPendingVerificationCount<
  TData = Awaited<ReturnType<typeof getPendingVerificationCount>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetPendingVerificationCountParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetPendingVerificationCountQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Verification] Get Pending Verification Count
 */
export const prefetchGetPendingVerificationCountQuery = async <
  TData = Awaited<ReturnType<typeof getPendingVerificationCount>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetPendingVerificationCountParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPendingVerificationCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetPendingVerificationCountQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};
