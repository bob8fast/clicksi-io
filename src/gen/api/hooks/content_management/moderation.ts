/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * ContentManagement.API
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  ClicksiDataContractsCommonModelsResponsesPagedResult1ContentManagementAPIModelsContentReportResponse,
  ClicksiDataContractsCommonModelsResponsesPagedResult1ContentManagementAPIModelsModerationActionResponse,
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  ContentManagementAPIModelsContentReportResponse,
  ContentManagementAPIModelsModerateContentRequest,
  ContentManagementAPIModelsResolveReportRequest,
  GetModerationActionsParams,
  GetModerationQueueParams,
  GetReportPathParameters,
  GetReportsParams,
  ModerateContentPathParameters,
  ResolveReportPathParameters,
} from "../../types";

import { gatewayServiceCustomFetch } from "../../../../lib/orval/orval-fetch";
import { customQueryOptions } from "../../../../lib/orval/custom-query-options";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary [Moderation] Get Moderation Actions
 */
export const getGetModerationActionsUrl = (
  params?: GetModerationActionsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/content-management/api/v1/moderation/actions?${stringifiedParams}`
    : `/content-management/api/v1/moderation/actions`;
};

export const getModerationActions = async (
  params?: GetModerationActionsParams,
  options?: RequestInit,
): Promise<ClicksiDataContractsCommonModelsResponsesPagedResult1ContentManagementAPIModelsModerationActionResponse> => {
  return gatewayServiceCustomFetch<ClicksiDataContractsCommonModelsResponsesPagedResult1ContentManagementAPIModelsModerationActionResponse>(
    getGetModerationActionsUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetModerationActionsQueryKey = (
  params?: GetModerationActionsParams,
) => {
  return [
    "content-management",
    "api",
    "v1",
    "moderation",
    "actions",
    ...(params ? [params] : []),
  ] as const;
};

export const useGetModerationActionsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getModerationActions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationActionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetModerationActionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getModerationActions>>
  > = ({ signal }) =>
    getModerationActions(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getModerationActions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetModerationActionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getModerationActions>>
>;
export type GetModerationActionsInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetModerationActionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getModerationActions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetModerationActionsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModerationActions>>,
          TError,
          Awaited<ReturnType<typeof getModerationActions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetModerationActionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getModerationActions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationActionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModerationActions>>,
          TError,
          Awaited<ReturnType<typeof getModerationActions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetModerationActionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getModerationActions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationActionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Moderation] Get Moderation Actions
 */

export function useGetModerationActionsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getModerationActions>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationActionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetModerationActionsInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Moderation] Get Moderation Actions
 */
export const prefetchGetModerationActionsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getModerationActions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetModerationActionsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetModerationActionsInfiniteQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetModerationActionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getModerationActions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationActionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetModerationActionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getModerationActions>>
  > = ({ signal }) =>
    getModerationActions(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getModerationActions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetModerationActionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getModerationActions>>
>;
export type GetModerationActionsQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetModerationActions<
  TData = Awaited<ReturnType<typeof getModerationActions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetModerationActionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModerationActions>>,
          TError,
          Awaited<ReturnType<typeof getModerationActions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetModerationActions<
  TData = Awaited<ReturnType<typeof getModerationActions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationActionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModerationActions>>,
          TError,
          Awaited<ReturnType<typeof getModerationActions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetModerationActions<
  TData = Awaited<ReturnType<typeof getModerationActions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationActionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Moderation] Get Moderation Actions
 */

export function useGetModerationActions<
  TData = Awaited<ReturnType<typeof getModerationActions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationActionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetModerationActionsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Moderation] Get Moderation Actions
 */
export const prefetchGetModerationActionsQuery = async <
  TData = Awaited<ReturnType<typeof getModerationActions>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetModerationActionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationActions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetModerationActionsQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary [Moderation] Moderate Content
 */
export const getModerateContentUrl = ({
  contentId,
}: ModerateContentPathParameters) => {
  return `/content-management/api/v1/moderation/contents/${contentId}/moderate`;
};

export const moderateContent = async (
  { contentId }: ModerateContentPathParameters,
  contentManagementAPIModelsModerateContentRequest: ContentManagementAPIModelsModerateContentRequest,
  options?: RequestInit,
): Promise<void> => {
  return gatewayServiceCustomFetch<void>(getModerateContentUrl({ contentId }), {
    ...options,
    method: "POST",
    headers: {
      "Content-Type": "application/json-patch+json",
      ...options?.headers,
    },
    body: JSON.stringify(contentManagementAPIModelsModerateContentRequest),
  });
};

export const getModerateContentMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof moderateContent>>,
    TError,
    {
      pathParams: ModerateContentPathParameters;
      data: ContentManagementAPIModelsModerateContentRequest;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof moderateContent>>,
  TError,
  {
    pathParams: ModerateContentPathParameters;
    data: ContentManagementAPIModelsModerateContentRequest;
  },
  TContext
> => {
  const mutationKey = ["moderateContent"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof moderateContent>>,
    {
      pathParams: ModerateContentPathParameters;
      data: ContentManagementAPIModelsModerateContentRequest;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return moderateContent(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ModerateContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof moderateContent>>
>;
export type ModerateContentMutationBody =
  ContentManagementAPIModelsModerateContentRequest;
export type ModerateContentMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary [Moderation] Moderate Content
 */
export const useModerateContent = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof moderateContent>>,
      TError,
      {
        pathParams: ModerateContentPathParameters;
        data: ContentManagementAPIModelsModerateContentRequest;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof moderateContent>>,
  TError,
  {
    pathParams: ModerateContentPathParameters;
    data: ContentManagementAPIModelsModerateContentRequest;
  },
  TContext
> => {
  const mutationOptions = getModerateContentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary [Moderation] Get Moderation Queue
 */
export const getGetModerationQueueUrl = (params?: GetModerationQueueParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/content-management/api/v1/moderation/queue?${stringifiedParams}`
    : `/content-management/api/v1/moderation/queue`;
};

export const getModerationQueue = async (
  params?: GetModerationQueueParams,
  options?: RequestInit,
): Promise<ClicksiDataContractsCommonModelsResponsesPagedResult1ContentManagementAPIModelsContentReportResponse> => {
  return gatewayServiceCustomFetch<ClicksiDataContractsCommonModelsResponsesPagedResult1ContentManagementAPIModelsContentReportResponse>(
    getGetModerationQueueUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetModerationQueueQueryKey = (
  params?: GetModerationQueueParams,
) => {
  return [
    "content-management",
    "api",
    "v1",
    "moderation",
    "queue",
    ...(params ? [params] : []),
  ] as const;
};

export const useGetModerationQueueInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getModerationQueue>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationQueueParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetModerationQueueQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getModerationQueue>>
  > = ({ signal }) => getModerationQueue(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getModerationQueue>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetModerationQueueInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getModerationQueue>>
>;
export type GetModerationQueueInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetModerationQueueInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getModerationQueue>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetModerationQueueParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModerationQueue>>,
          TError,
          Awaited<ReturnType<typeof getModerationQueue>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetModerationQueueInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getModerationQueue>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationQueueParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModerationQueue>>,
          TError,
          Awaited<ReturnType<typeof getModerationQueue>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetModerationQueueInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getModerationQueue>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationQueueParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Moderation] Get Moderation Queue
 */

export function useGetModerationQueueInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getModerationQueue>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationQueueParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetModerationQueueInfiniteQueryOptions(
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Moderation] Get Moderation Queue
 */
export const prefetchGetModerationQueueInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getModerationQueue>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetModerationQueueParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetModerationQueueInfiniteQueryOptions(
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetModerationQueueQueryOptions = <
  TData = Awaited<ReturnType<typeof getModerationQueue>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationQueueParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetModerationQueueQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getModerationQueue>>
  > = ({ signal }) => getModerationQueue(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getModerationQueue>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetModerationQueueQueryResult = NonNullable<
  Awaited<ReturnType<typeof getModerationQueue>>
>;
export type GetModerationQueueQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetModerationQueue<
  TData = Awaited<ReturnType<typeof getModerationQueue>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetModerationQueueParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModerationQueue>>,
          TError,
          Awaited<ReturnType<typeof getModerationQueue>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetModerationQueue<
  TData = Awaited<ReturnType<typeof getModerationQueue>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationQueueParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getModerationQueue>>,
          TError,
          Awaited<ReturnType<typeof getModerationQueue>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetModerationQueue<
  TData = Awaited<ReturnType<typeof getModerationQueue>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationQueueParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Moderation] Get Moderation Queue
 */

export function useGetModerationQueue<
  TData = Awaited<ReturnType<typeof getModerationQueue>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetModerationQueueParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetModerationQueueQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Moderation] Get Moderation Queue
 */
export const prefetchGetModerationQueueQuery = async <
  TData = Awaited<ReturnType<typeof getModerationQueue>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetModerationQueueParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getModerationQueue>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetModerationQueueQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary [Moderation] Get Reports
 */
export const getGetReportsUrl = (params?: GetReportsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/content-management/api/v1/moderation/reports?${stringifiedParams}`
    : `/content-management/api/v1/moderation/reports`;
};

export const getReports = async (
  params?: GetReportsParams,
  options?: RequestInit,
): Promise<ClicksiDataContractsCommonModelsResponsesPagedResult1ContentManagementAPIModelsContentReportResponse> => {
  return gatewayServiceCustomFetch<ClicksiDataContractsCommonModelsResponsesPagedResult1ContentManagementAPIModelsContentReportResponse>(
    getGetReportsUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetReportsQueryKey = (params?: GetReportsParams) => {
  return [
    "content-management",
    "api",
    "v1",
    "moderation",
    "reports",
    ...(params ? [params] : []),
  ] as const;
};

export const useGetReportsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getReports>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetReportsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReports>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReportsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReports>>> = ({
    signal,
  }) => getReports(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getReports>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReportsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReports>>
>;
export type GetReportsInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetReportsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReports>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetReportsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReports>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReports>>,
          TError,
          Awaited<ReturnType<typeof getReports>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetReportsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReports>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetReportsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReports>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReports>>,
          TError,
          Awaited<ReturnType<typeof getReports>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetReportsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReports>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetReportsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReports>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Moderation] Get Reports
 */

export function useGetReportsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReports>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetReportsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReports>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetReportsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Moderation] Get Reports
 */
export const prefetchGetReportsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getReports>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetReportsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReports>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetReportsInfiniteQueryOptions(params, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetReportsQueryOptions = <
  TData = Awaited<ReturnType<typeof getReports>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetReportsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReports>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReportsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReports>>> = ({
    signal,
  }) => getReports(params, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getReports>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReportsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReports>>
>;
export type GetReportsQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetReports<
  TData = Awaited<ReturnType<typeof getReports>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params: undefined | GetReportsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReports>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReports>>,
          TError,
          Awaited<ReturnType<typeof getReports>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetReports<
  TData = Awaited<ReturnType<typeof getReports>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetReportsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReports>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReports>>,
          TError,
          Awaited<ReturnType<typeof getReports>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetReports<
  TData = Awaited<ReturnType<typeof getReports>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetReportsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReports>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Moderation] Get Reports
 */

export function useGetReports<
  TData = Awaited<ReturnType<typeof getReports>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  params?: GetReportsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReports>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetReportsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Moderation] Get Reports
 */
export const prefetchGetReportsQuery = async <
  TData = Awaited<ReturnType<typeof getReports>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  params?: GetReportsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReports>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetReportsQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary [Moderation] Get Report
 */
export const getGetReportUrl = ({ reportId }: GetReportPathParameters) => {
  return `/content-management/api/v1/moderation/reports/${reportId}`;
};

export const getReport = async (
  { reportId }: GetReportPathParameters,
  options?: RequestInit,
): Promise<ContentManagementAPIModelsContentReportResponse> => {
  return gatewayServiceCustomFetch<ContentManagementAPIModelsContentReportResponse>(
    getGetReportUrl({ reportId }),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetReportQueryKey = ({ reportId }: GetReportPathParameters) => {
  return [
    "content-management",
    "api",
    "v1",
    "moderation",
    "reports",
    reportId,
  ] as const;
};

export const useGetReportInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getReport>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { reportId }: GetReportPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReport>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReportQueryKey({ reportId });

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReport>>> = ({
    signal,
  }) => getReport({ reportId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getReport>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReportInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReport>>
>;
export type GetReportInfiniteQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetReportInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReport>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetReportPathParameters,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReport>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReport>>,
          TError,
          Awaited<ReturnType<typeof getReport>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetReportInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReport>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetReportPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReport>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReport>>,
          TError,
          Awaited<ReturnType<typeof getReport>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetReportInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReport>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetReportPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReport>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Moderation] Get Report
 */

export function useGetReportInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getReport>>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { reportId }: GetReportPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReport>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetReportInfiniteQueryOptions({ reportId }, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Moderation] Get Report
 */
export const prefetchGetReportInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof getReport>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { reportId }: GetReportPathParameters,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getReport>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetReportInfiniteQueryOptions({ reportId }, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

export const useGetReportQueryOptions = <
  TData = Awaited<ReturnType<typeof getReport>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { reportId }: GetReportPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReport>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReportQueryKey({ reportId });

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReport>>> = ({
    signal,
  }) => getReport({ reportId }, { signal, ...requestOptions });

  const customOptions = customQueryOptions({
    ...queryOptions,
    queryKey,
    queryFn,
  });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof getReport>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetReportQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReport>>
>;
export type GetReportQueryError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

export function useGetReport<
  TData = Awaited<ReturnType<typeof getReport>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetReportPathParameters,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReport>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReport>>,
          TError,
          Awaited<ReturnType<typeof getReport>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetReport<
  TData = Awaited<ReturnType<typeof getReport>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetReportPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReport>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReport>>,
          TError,
          Awaited<ReturnType<typeof getReport>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetReport<
  TData = Awaited<ReturnType<typeof getReport>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  pathParams: GetReportPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReport>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary [Moderation] Get Report
 */

export function useGetReport<
  TData = Awaited<ReturnType<typeof getReport>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  { reportId }: GetReportPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReport>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = useGetReportQueryOptions({ reportId }, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary [Moderation] Get Report
 */
export const prefetchGetReportQuery = async <
  TData = Awaited<ReturnType<typeof getReport>>,
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
>(
  queryClient: QueryClient,
  { reportId }: GetReportPathParameters,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getReport>>, TError, TData>
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = useGetReportQueryOptions({ reportId }, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * @summary [Moderation] Resolve Report
 */
export const getResolveReportUrl = ({
  reportId,
}: ResolveReportPathParameters) => {
  return `/content-management/api/v1/moderation/reports/${reportId}/resolve`;
};

export const resolveReport = async (
  { reportId }: ResolveReportPathParameters,
  contentManagementAPIModelsResolveReportRequest: ContentManagementAPIModelsResolveReportRequest,
  options?: RequestInit,
): Promise<void> => {
  return gatewayServiceCustomFetch<void>(getResolveReportUrl({ reportId }), {
    ...options,
    method: "POST",
    headers: {
      "Content-Type": "application/json-patch+json",
      ...options?.headers,
    },
    body: JSON.stringify(contentManagementAPIModelsResolveReportRequest),
  });
};

export const getResolveReportMutationOptions = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resolveReport>>,
    TError,
    {
      pathParams: ResolveReportPathParameters;
      data: ContentManagementAPIModelsResolveReportRequest;
    },
    TContext
  >;
  request?: SecondParameter<typeof gatewayServiceCustomFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resolveReport>>,
  TError,
  {
    pathParams: ResolveReportPathParameters;
    data: ContentManagementAPIModelsResolveReportRequest;
  },
  TContext
> => {
  const mutationKey = ["resolveReport"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resolveReport>>,
    {
      pathParams: ResolveReportPathParameters;
      data: ContentManagementAPIModelsResolveReportRequest;
    }
  > = (props) => {
    const { pathParams, data } = props ?? {};

    return resolveReport(pathParams, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResolveReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof resolveReport>>
>;
export type ResolveReportMutationBody =
  ContentManagementAPIModelsResolveReportRequest;
export type ResolveReportMutationError =
  ClicksiDataContractsProblemDetailsRootProblemDetailsDto;

/**
 * @summary [Moderation] Resolve Report
 */
export const useResolveReport = <
  TError = ClicksiDataContractsProblemDetailsRootProblemDetailsDto,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resolveReport>>,
      TError,
      {
        pathParams: ResolveReportPathParameters;
        data: ContentManagementAPIModelsResolveReportRequest;
      },
      TContext
    >;
    request?: SecondParameter<typeof gatewayServiceCustomFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof resolveReport>>,
  TError,
  {
    pathParams: ResolveReportPathParameters;
    data: ContentManagementAPIModelsResolveReportRequest;
  },
  TContext
> => {
  const mutationOptions = getResolveReportMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
